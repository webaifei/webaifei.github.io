{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"webaifei","url":"http://yoursite.com"},"pages":[{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2019-08-16T09:32:51.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2019-08-16T09:33:02.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"lodash部分源码阅读","slug":"read-lodash","date":"2018-06-24T01:33:06.000Z","updated":"2019-08-16T05:58:48.000Z","comments":true,"path":"2018/06/24/read-lodash/","link":"","permalink":"http://yoursite.com/2018/06/24/read-lodash/","excerpt":"","text":"lodash 源码本身短小精悍 比较适合阅读，代码质量很高，涉及一些常见算法的应用。 函数方法before 调用方式 123//_.before(n, func);// 点击触发3次之后 将不再调用执行func$(dom).on(&apos;click&apos;, _.before(4, func)); 实现 123456789101112function before(n, func) &#123; let result; return function (...args) &#123; if(--n &gt;= 1) &#123; result = func.apply(this, args); &#125; else &#123; func = undefined; &#125; return result; &#125;&#125; 知识点应用 闭包保存参数n , func after 使用方法 12345678910//_.after(n, func)// 在被调用n次的时候， 执行funcvar saves = [&apos;profile&apos;, &apos;settings&apos;]; var done = _.after(saves.length, function() &#123; console.log(&apos;done saving!&apos;);&#125;);_.forEach(saves, function(type) &#123; asyncSave(&#123; &apos;type&apos;: type, &apos;complete&apos;: done &#125;);&#125;); 实现 12345678function after(n, func) &#123; return function (...args) &#123; if(--n &lt; 0) &#123; return func.apply(this, args); &#125; &#125;&#125; 应用知识点 使用闭包将n，func参数存储起来","categories":[],"tags":[{"name":"源码解读","slug":"源码解读","permalink":"http://yoursite.com/tags/源码解读/"},{"name":"lodash","slug":"lodash","permalink":"http://yoursite.com/tags/lodash/"}]},{"title":"函数式编程","slug":"function-programimg","date":"2018-05-20T12:27:55.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/20/function-programimg/","link":"","permalink":"http://yoursite.com/2018/05/20/function-programimg/","excerpt":"","text":"curry 柯里化https://hackernoon.com/currying-in-js-d9ddc64f162e","categories":[],"tags":[{"name":"函数式","slug":"函数式","permalink":"http://yoursite.com/tags/函数式/"}]},{"title":"js算法","slug":"js-algorithm","date":"2018-05-20T08:03:52.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/20/js-algorithm/","link":"","permalink":"http://yoursite.com/2018/05/20/js-algorithm/","excerpt":"","text":"求一个数组中最大的差值123456789101112131415161718192021222324251. 第一种实现\b方案：先排序，然后最大值-最小值2. 第二种实现方案：遍历过程中找到最大的差值function getMaxPro(arr)&#123; var minPrice=arr[0]; var maxProfit=0; for (var i=0;i&lt;arr.length;i++)&#123; var currentPrice=arr[i]; minPrice=Math.min(minPrice,currentPrice); var potentialProfit =currenrPrice-minPrice; maxProfit=Math.max(maxProfit,potentialProfit); &#125; return maxProfit; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"web安全","slug":"web-safe","date":"2018-05-19T14:07:02.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/19/web-safe/","link":"","permalink":"http://yoursite.com/2018/05/19/web-safe/","excerpt":"","text":"常见的web安全问题XSS 攻击 \b\b跨站脚本攻击(Cross Site Script),为了和CSS区别，所以简称XSS XSS 利用网站没有对用户提交的数据进行转义处理或者过滤，导致恶意脚本被执行，最终\b用户的信息被窃取等严重后果 例子： 一个网站的评论功能没有对用户评论的内容没有进行过滤和处理，存储到了数据库中，然后直接展现到了页面中，执行了js代码，插入了一张华丽丽的图片引导用户\b点击到其他的站点，甚至将用户的信息，cookie的窃取 CSRF (跨站请求伪造) 利用用户对于目标站点的信任，引诱或者在用户不知情的情况下，\b通过利用网站验证的漏洞（简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。） 例子： 假如一家银行用以执行转账操作的URL地址如下： 1http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： 1&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt; 如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。 所以，需要具备以下的条件就会\bCSRF得逞 用户登录了信任网站 session未过期，\b用户\b这个时候访问了其他的站点，这个站点中包含了一个请求信任站点某个接口（例如转账、关注等），而这些接口也没有其他的认证措施，导致信任网站受到攻击。 防范措施： referer字段验证 添加token校验","categories":[],"tags":[{"name":"web安全","slug":"web安全","permalink":"http://yoursite.com/tags/web安全/"}]},{"title":"MV*架构","slug":"mvvm","date":"2018-05-19T07:51:18.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/19/mvvm/","link":"","permalink":"http://yoursite.com/2018/05/19/mvvm/","excerpt":"","text":"前端的洪荒时代只是提供表单提交验证等简单的功能，随着异步加载技术的出现，前端在客户端&lt;=&gt;服务器交互中扮演的角色越来越重要，其最终的目的是为用户提供更优的体验，同时也促进了前端职业化进程（我们不再只是切图仔！）在CS结构向桌面应用程序接近的同时，越来越复杂的业务逻辑使得前端人员开始思考将桌面应用的思想搬到前端实践中。 复杂的程序设计 必须有清晰合理的架构， 否则很难开发和维护 发展历程MVC 应该是应用最广的架构模式了吧，或者说是最基本的架构模式，很多其他的模式都是基于它衍生而来。 MVC 大家都了解， Model+View+Controller, 离用户最近的是View，这里接受用户的操作，给出反馈，然后View把相关的操作交给Controller，Controller去影响Model，然后再反馈到View，特点就是通信是单向的。 但是实际过程中，可能比较灵活，因为前端开发中很大的工作量都在操作DOM。 早期比较火的MVC库有backbone.js 当前火爆的React 以及 vuejs 其实将React和vuejs列入MVC框架中，不太妥当，两者都是用于构架ui层（view），并不包含模块加载，路由，数据管理，异步等utils集合。 MVP 将C替换成了P （presenter），他像一个控制调度中心，和View、Model进行双向通信，但是，View和Model之间不发生通信，这样 整个业务逻辑都在P这一层。 前端实现库riotjs MVVM 将P改成了VM（viewModel），基本上和MVP相同，不同的地方是VM和View之间双向绑定。 比较流行的如： angular.js react 和 vuejs对比 对比项 react vuejs 备注 组件化、声明\b式 🆗 🆗 模板语法 jsx 默认使用模板语法，也支持jsx virtual dom + diff algorithm 🆗 🆗 \b组件\b性能优化 🆗 🆗 vue实现了\b自动依赖追踪技术，不需要手动的实现shouldComponentUpdate，更加容易，同时也更加依赖底层，自由度较低 服务端渲染 🆗 🆗 跨终端 🆗 🆗 相比而言 RN要比 Weex更加成熟 社区活跃度 🔆🔆🔆 🔆🔆 相比而言 react的社区更加活跃 \b脚手架 🔆 🔆🔆 相比而言 vue的\b脚手架做的更加完善","categories":[],"tags":[{"name":"mv*","slug":"mv","permalink":"http://yoursite.com/tags/mv/"}]},{"title":"http协议","slug":"http-protocal","date":"2018-05-19T02:52:53.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/19/http-protocal/","link":"","permalink":"http://yoursite.com/2018/05/19/http-protocal/","excerpt":"","text":"\bhttp协议http协议是应用层协议族中的一员，是web通信基础。http协议\b\b建立在TCP（TCP是网络传输层的一个协议）协议\b之上。 http报文格式http报文分为请求报文和响应报文，报文包含了起始行、首部、实体的主题三个部分，其中起始行和首部都是ASCII\b文本，主体部分可以是任意数据格式的数据块。 请求报文格式 请求起始行：包含 请求方法、请求url、HTTP协议和版本 请求首部，以key: value形式的结构 空行（必须有） 请求实体：任意数据组成的数据块（可以是ASCII文本或者是二进制数据等等）12345GET /home HTTP/1.1HOST: www.baidu.comConnection: keep-aliveCache-Control: max-age=100000Cookie: xxxx=sss; 响应报文格式 响应起始行：包含 HTTP协议版本、响应状态码、原因短语 响应首部：以行分割的 key: value格式 响应实体123456HTTP/1.1 200 okConnection: keep-aliveCache-Control: no-cacheContent-Type: text/htmlContent-Length: 1100Set-Cookie: name=ngnice; 请求方法GET,POST,HEAD,PUT,DELETE,OPTIONS,TRACE,常见的是GET,POST,HEAD,OPTIONS 响应状态码 200系列 12200 OK204 No Content (CORS跨域设置中针对 OPTIONS的请求有这个设置) 300系列 code 状态描述 含义 备注 301 Moved Permanently 永久重定向 302 Found 临时重定向 将来的请求还是使用老的URL 307 Temporary Redirect 临时重定向 将来的请求还是使用老的URL 304 Not Modified 协商缓存 1. 响应主体不返回内容 \u001c 2. 必须是GET请求 TIPS:1231. 如果是重定向的code 但是没有给Location首部字段 那么响应还是之前的（因为不知道重定向到了什么地方）2. 302\b和307都是告诉浏览器请求的资源临时重定向到其他的地址了，下次\b请求还是请求老的地址，区别是302在HTTP/1.0中使用，307是HTTP/1.1中使用的3. 302和307的另外一个表现是：如果客户端发起一个POST请求，服务器返回一个302或者307 ，客户端将使用GET方法请求重定向的地址 400系列 code 状态描述 含义 备注 403 Forbidden 被服务器拒绝 404 Not Found 没有找到对应的资源 405 Method Not Allowed 请求的方法不\b支持 408 Time out 超时 500系列 code 状态描述 含义 备注 500 Internal Server Error 一般是服务器代码出错 404 Not Found 没有找到对应的资源 405 Method Not Allowed 请求的方法不\b支持 408 Time out 超时 http缓存关于http缓存header这个文章讲的不错[http缓存]","categories":[],"tags":[{"name":"http 计算机网络","slug":"http-计算机网络","permalink":"http://yoursite.com/tags/http-计算机网络/"}]},{"title":"react最佳实践","slug":"react-practice","date":"2018-05-18T06:37:03.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/18/react-practice/","link":"","permalink":"http://yoursite.com/2018/05/18/react-practice/","excerpt":"","text":"react 最佳实践 增加属性类型检测 代码的健壮性 12345import PropTypes from &apos;prop-types&apos;;YourComponent.propTypes = &#123; name: PropTypes.string&#125;; 默认属性设置 123YourComponent.defaultProps = &#123; name: &apos;Stranger&apos;&#125;; 使用 react-dev-tool 来检测 使用shouldComponentUpdate或者使用PureComponent实现性能优化 在constructor中绑定this 123456// 避免下面的用法&lt;a onClick=&#123;(e)=&gt;this.clickHandle(e)&#125;&gt;// 使用如下方法来实现constructor() &#123; this.clickHandle = this.clickHandle.bind(this)&#125; 使用key，并且正确使用key帮助react提升性能 注意不要给子组件的key设置为index 因为这样并没有解决我们的问题 详见react diff 算法 请把异步请求等side effect 操作 放到componentDidMount中具体原因参考：客户端请求应该放到什么地方","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"react diff算法","slug":"react-diff-md","date":"2018-05-18T06:35:30.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2018/05/18/react-diff-md/","link":"","permalink":"http://yoursite.com/2018/05/18/react-diff-md/","excerpt":"","text":"diff 算法 virtual dom技术 将我们的DOM树在内存中存放了一份JS的对象映射（js本身的执行效率很高，操作DOM的代价昂贵） 传统的树结构比较传统的将一颗树转换成另外一棵树的算法复杂度是O(n^3)(算法实现待研究)，那么我们现在有1000个dom节点的话，就是一亿次计算量 简单例子中 只是一个简单的计算（一亿次）但是，平均耗时是2.4s，可以想象我们如果进行了更加复杂的逻辑处理会是什么情况~ 如何从O(n^3)实现O(n)算法 基于两点假设 Two elements of different types will produce different trees.（不同类型的元素将会产生不同的树） The developer can hint at which child elements may be stable across different renders with a key prop.(开发者可以通过为同一层的子节点添加唯一key属性来优化) DOM节点在不同层级的位置调整操作很少，可以忽略不计，实际项目中我们的DOM操作基本上几种这几个方面 显示，隐藏元素， 包含简单节点和复杂节点（比如列表页，切换到了详情页） 更改某个元素的样式 新增，删除，移动某个元素 根据两个假设需要注意的事情 相同的结构不要更改父节点的类型（千万不要这么干）12345678// 当返回跳转地址的时候 &lt;a href=&#123;href&#125;&gt; &lt;YourComponent/&gt; // 比较复杂的一个组件&lt;/a&gt;// 没有返回跳转地址的时候&lt;p&gt; &lt;YourComponent/&gt;&lt;/p&gt; 当然，如果你的子组件如果很简单的话，可以忽略这条 为同一层级的子组件添加key属性 12345// key属性一定是唯一不变化的&lt;ul&gt; &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;&lt;/ul&gt; 算法过程 Elements Of Different Types 1针对不同类型的元素的比较，react处理策略根据假设1 直接销毁原来的元素，创建新的节点 DOM Elements Of The Same Type 1针对同种类型的React DOM 元素，react比对两个元素的属性，找到属性不同的地方进行更新 Component Elements Of The Same Type 12345针对相同类型的组件元素，默认情况下，使用新的props和state 调用render 生成一颗新树， 然后和之前的树进行递归对比如果我们重写了shouldComponentUpdate或者是继承了 PureComponent ，那么就会根据作者的意图来选择是否执行render，生成一颗新树进行diff algorithm Recursing On Children（递归比较子组件） 12345678910111213141516171819经过上面3中比较之后，react就会对两棵树的children进行比较4.1 默认情况下，在递归一个DOM node 的 children的时候，react仅仅是同时遍历两个children的list，找到不同的节点进行对应的操作 1) 节点类型不同 直接删除原节点 添加新节点 2) 节点类型相同 属性不同 修改属性 3) 都相同那就不做修改对于在children列表非最后的位置插入新节点，可能会有如下的问题：&lt;ul&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li&gt;Connecticut&lt;/li&gt; &lt;li&gt;Duke&lt;/li&gt; &lt;li&gt;Villanova&lt;/li&gt;&lt;/ul&gt;react在遍历新旧节点list的时候发现 都节点属性都变换了，所以会造成三个节点都被修改一次，并不能准确的知道我们只是在开始的位置插入了一个新的节点（而在dom操作中 这种插入操作又非常的常见） 4.2 未children 添加key属性为了解决上面的问题，react支持通过添加key来进行优化12345678910111213141516&lt;ul&gt; &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt; &lt;li key=&quot;Connecticut&quot;&gt;Connecticut&lt;/li&gt; &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt; &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;&lt;/ul&gt;这样，react在遍历children的子元素的时候 可以通过key来确认这个节点到底是否发生了变化TIPS: 请注意上面的写法，key并不是取数组的索引，因为那样的话，和没有增加key的结果一样，并不会帮助react意识到哪个节点发生了变化，哪些没有然后再实际开发中，这样的代码却随处可见","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"connectjs源码解读","slug":"connnect-js","date":"2017-11-25T14:46:39.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/25/connnect-js/","link":"","permalink":"http://yoursite.com/2017/11/25/connnect-js/","excerpt":"","text":"connect基本思路 app.use方法入栈 1234567891011var app = connect();// 第一个中间件app.use(&apos;/app&apos;, function fn1(req, res, next)&#123; next();&#125;);// 第二个中间件app.use(&apos;/app/list&apos;, function fn2(req, res, next)&#123; next();&#125;)// app作为接收到请求的事件函数 被调用http.createServer(app).listen(3000) 执行第一个中间件 12345var route = &#123; route: &apos;/app&apos;, handle: fn1&#125;app.stack.push(route) 执行第二个中间件 12345var route = &#123; route: &apos;/app/list&apos;, handle: fn1&#125;app.stack.push(route) 访问的时候 调用next出栈 12345//访问路径是app/appapp内部调用定义的next方法1. 出栈添加的中间件2. 查看当前中间件的route是否在当前的访问路径中 继续next 直到没有可以出栈的中间件为止 基本框架1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var EventEmitter = require(&apos;evnets&apos;).EventEmitter;module.exports = createServer;var proto = &#123;&#125;;function createServer ()&#123; function app (req, res, next)&#123; app.handle(req, res, next); &#125; merge(app, proto); merge(app, EventEmitter.prototype) app.stack = []; app.route = &apos;/&apos;; return app;&#125;proto = &#123; use: function (route, fn)&#123; // 参数处理 // code here this.stack.push(&#123; route: route, handle: fn &#125;) //链式调用 return this; &#125;, handle: function (req, res, next)&#123; var index = 0; var stack = this.stack; function next(err) &#123; var layer = stack[index++]; if(!layer) &#123; //all done // code here return; &#125; var route = layer.route; var path = parseUrl(req).pathname || &apos;/&apos;;//获取当前请求路径 //如果当前调用的中间件的route 和当前请求路径不匹配 则执行下一个中间件 if(path.toLowerCase().substr(0, route.length) !== route.toLowerCase())&#123; return next(err); &#125; &#125; next(err); &#125;&#125; TODO 为啥每次修改 req.url 其他容错处理","categories":[],"tags":[{"name":"connect.js","slug":"connect-js","permalink":"http://yoursite.com/tags/connect-js/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"前端模板实现","slug":"template-fe","date":"2017-11-11T14:39:09.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/11/template-fe/","link":"","permalink":"http://yoursite.com/2017/11/11/template-fe/","excerpt":"","text":"一步一步实现自己的前端模板 最终的调用方法：12345678function template(string, data)&#123; //code here &#125;var str = &apos;this is the &#123;&#123;name&#125;&#125;&apos;;template(str, &#123; name: &apos;allo&apos;&#125;) 如何实现变量替换呢? 这里用到了两个正则方法 replace 方法返回一个由替换值替换一些或所有匹配的模式后的新字符串 (不会影响原来字符串) exec 在一个指定字符串中执行一个搜索匹配。返回一个数据或者null 123456789var varReg =/\\&#123;\\&#123;([^\\&#125;]+)?\\&#125;\\&#125;/g;//varReg.lastIndex 标记了下一次开始检索的位置 varReg.exec(str)[ &apos;&#123;&#123;name&#125;&#125;&apos;, &apos;name&apos;, index: 22, input: &apos;this is the &#123;&#123;name&#125;&#125;&apos;] 遍历所有的匹配项 进行替换 12345678910function template(str, data)&#123; var varReg = /\\&#123;\\&#123;([a-zA-Z_\\$])+\\&#125;\\&#125;/g; var tpl = &apos;&apos;; while( match = varReg.exec(str) ) &#123; var replaceStr = match[0], replaceKey = match[1]; tpl = str.replace(replaceStr, data[replaceKey]); &#125; return tpl; &#125; 上面的代码有些问题，并不能支持如下的情况 12345678var data = &#123; info: &#123; title:&apos;title here&apos; &#125;&#125;var str = &apos;this is the &#123;&#123;info.title&#125;&#125;&apos;;使用上面的函数执行 &#123;&#123;info.title&#125;&#125; 将不会被替换str.replace(str, data[info.title]);//","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"前端模板","slug":"前端模板","permalink":"http://yoursite.com/tags/前端模板/"}]},{"title":"git基本命令","slug":"git","date":"2017-11-09T11:50:44.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/git/","link":"","permalink":"http://yoursite.com/2017/11/09/git/","excerpt":"","text":"工作区－》暂存区－》本地仓库－》远程仓库 clone已有的项目 1git clone project-git-url 初始化一个新的仓库 1git init 把新增的文件添加到我们的暂存区 1git add xxx or . 把暂存区中的文件提交到本地仓库 1git commit -m &apos;some msg for this commit &apos; 推送到远程的仓库 12345//1 如果local_branch 不存在 会报错//2. 如果省略了冒号和后面的远程分支名 代表远程分支名和本地分支名一样//3. 如果远程分支名不存在的话 就会创建一个新的远程分支//4. 如果local_branch 没写 是一个空格 那么就会删除远程分支git push origin local_branch:remote_branch 我错误的提交了一些文件 怎么删除掉呢 12git rm --cached xxx //从仓库中删除 而保留原文件git rm -f xxx //从仓库中和本地删除文件（文件真实的被干掉了！！） 使用git reset 来进行版本的回退 123git reset --hard commit_id(某次的版本号)//HEAD 表示的是当前版本 ^表示上一个版本git reset --hard HEAD^ *git log 来查看历史commit的记录 123git log// 格式话输出git log --pretty=oneline git reflog 用来显示之前的操作记录 git checkout – xxx 用来撤撤销add之后没有commit又进行的修改 满足两个条件： 1 add 了 2. 没有commit又进行了修改 用来找回 已经add过误删的文件 git checkout -t remote_branch // 用来从远程拉取指定分支 并且在本地新建同名分支 而且和远程分支已经关联 添加远程仓库 1git remote add origin xxxx 把本地仓库的代码推送到远程仓库 1git push -u origin master 分支管理 1234567git branch //列出所有分支git branch -r //列出远程分支git branch xxx//新建分支xxxgit branch -d xxx删除分支git checkout xxx//切换到xxx分支git checkout -b xxx //新建分支并切换到xxx分支git merge xxx //合并xxx到当前分支 配置别名 1git config --global alias.st status","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"udp协议","slug":"network-udp","date":"2017-11-09T11:50:01.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/network-udp/","link":"","permalink":"http://yoursite.com/2017/11/09/network-udp/","excerpt":"","text":"运输层协议 运输层为它上层应用层提供服务。 互联网中的通信其实是在主机运行的应用进程进行的。 网际层实现的找到目的主机，交付ip数据报。 运输层是面向通信部分的最高层，也是用户功能的最底层，只有主机的协议栈中才有运输层。 运输层除了要把ip层交付的数据报交付给指定的进程，还要有分用和复用的功能。 两个运输层协议： 用户数据包协议（UDP） 传输控制协议 DUP 协议提供尽最大努力交付的服务。 传输之前不需要建立链接，自然传输结束之后也不需要断开连接 不保证传输的可靠性 每次都将应用进程的传递过来的数据加上首部字段 传递给IP层，不对数据进行分割。可能导致IP层进行分片，增加ip层的开销，或者由于运输数据单元过小，导致IP层的利用率降低。 因为不需要考虑传输的可靠性，所以实现相对较简单，系统资源开销小。所以比较适合：对数据安全要求比较低，对响应速度要求很高，网络负担很重的case。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"ip协议","slug":"network-ip","date":"2017-11-09T11:48:30.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/network-ip/","link":"","permalink":"http://yoursite.com/2017/11/09/network-ip/","excerpt":"","text":"IP 协议是TCP/IP协议栈中非常重要的一个协议 组成ip 地址 由 32位二进制数字组成（IPV4版本），分成两个部分： 网络ID 和 主机ID 网络id 在整个互联网是唯一的，而主机id在所在的网络id中是唯一的， 这样每一个ip地址都是唯一的。 ip地址分类 A类地址： 网络id占用一个字节，首位固定0，可用编号 0-127 B类地址： 网络id占用两个字节，前两位固定10 ，可用编号 128-191 C类地址： 网络id占用三个字节，前三位固定110 ，可用编号 192-223 D类地址：多播 E类 研究 IP地址的结构为啥是分级组成 方便管理，ip地址分配管理者只需要把网络id分配出去，即可，否则每一个主机的ip都需要分配的话，会死人的。 减少路由器内存，减少路由查询时间。不同的网络之间通信，通过路由器查询网络id来找到要送达的网络，而至于送到某个主机则由所在网络的路由器去完成，这样能很大程度上减少路由表的数据，减少路由查找时间。 ip地址为啥要分成这些类 因为需求不一样，有些公司接入的主机很多，需要一个能容纳很多主机的ip地址，有些则需要比较少的ip地址。 ip数据报传输过程 主机A发送数据报，本网络路由器查看路由表，目的主机B是否在同一网络，如果是同一个网络，那么就直接交付，不需要经过其他的路由器；如果不是，本网络路由器查找路由表找出下一跳的路由器，直到找到主机B所在网络的路由器，由它进行直接交付。 IP地址是逻辑上的地址，类似小明家这个概念。你去小明家肯定去的是一个具体的物理地址（坐标）。IP数据报在真正传输的过程中也需要找到目的主机IP地址对应的物理地址，才能交付。ARP（address resolution protocal）地址解析协议就是做这个工作的。对应的还有RARP（逆地址解析协议， 已经被DHCP协议替代） ARP协议实现原理 每一个主机都有一个ARP高速缓存（ARP cache），存储着各个主机和路由器的ip地址和硬件地址的映射表。那这个主机是怎么知道这些数据的呢？利用广播的原理，当一次通信请求过来时候，需要找下一跳的目的主机，如果发现目的主机的ip地址和物理地址不在自己的cache中的时候 就自动运行ARP进程发出一个广播：我是主机A，IP地址是128.0.1.xxx (可能通过逆地址解析出来)，物理地址是xxx，想要找IP地址是128.0.1.xxx的硬件地址。 然后本局域网中的所有主机都会收到这个广播，发现找的是自己就记录下主机A的ip地址和物理地址（以备后用），并响应：我的IP是xxx，物理地址是xxx。 TIPS: 高速缓存有生存周期，方便物理地址发生更改的时候，再次发起ARP广播，否则一直都是走cache 就over了。 ARP协议只是解决了局域网内ip地址到物理地址的转换。不同网络的传输，交给路由器来完成ARP解析。","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"http缓存","slug":"network-http","date":"2017-11-09T11:47:06.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/network-http/","link":"","permalink":"http://yoursite.com/2017/11/09/network-http/","excerpt":"","text":"http 协议是整个 互联网的基石之一。是web开发者必须关注的一个协议。 关于http缓存header这个文章讲的不错http缓存","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"linux 进程管理","slug":"linux-process","date":"2017-11-09T11:46:13.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/linux-process/","link":"","permalink":"http://yoursite.com/2017/11/09/linux-process/","excerpt":"","text":"进程管理 进程管理的首要目的是检查健康状况， 其次是进程管理：查找，终止 查看所有进程 1234// a 显示现行终端机下的所有进程，包括其他用户的进程。// u 以用户为主的格式来显示进程状况// x 显示所有进程，不以终端机来区分。 ps aux 查看健康状况 1top 终止进程 1234 //强制终止进程 kill -9 pid//重新启动进程kill -1 pid 工作管理 后台进程管理,只有程序运行期间不用用户参与的进程才能放入到后台（比如 mysql http服务等） 把进程放入后台 1your_commond &amp; 查看后台服务 1234jobs//-l 显示进程号jobs -l 放到前台运行 1fg %工作号 放到后台运行 1bg %工作号 后台进程脱离终端正常情况下，我们的进程在一个终端开启之后，如果关闭了当前的终端,终端会触发SIGHUP的信号，这样在当前终端绑定的进程就会被关闭怎么能够脱离当前的终端呢？ 12341. 在文件中启动进程2. 使用nohub命令执行命令nohup http-server &amp;","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"进程","slug":"进程","permalink":"http://yoursite.com/tags/进程/"}]},{"title":"FTP协议","slug":"app-protocol","date":"2017-11-09T11:45:09.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/app-protocol/","link":"","permalink":"http://yoursite.com/2017/11/09/app-protocol/","excerpt":"","text":"FTP协议 ftp(file transfer protocol) 文件传送协议 它屏蔽了各计算机系统的细节（各个计算机系统对文件系统的实现差异很大） 不同系统的计算机互传文件经常遇到的问题： 计算机存储的数据格式不同 文件的目录结构文件命名的规定不同 对于相同的文件存取功能，不同的系统使用的命令不同 访问控制方法不同 FTP的主要功能就是减少或者消除在不同操作系统下处理文件的不兼容性。 ftp是基于tcp实现的，工作的原理： 运行主进程监听 21端口（默认），等待客户链接 客户端请求链接 收到客户请求，分配从属进程处理客户端请求 处理完成之后 终止从属进程。 周而复始 TELNET telnet 是一个远程终端协议和ftp的工作原理比较类似，包含一个主进程和n个子进程","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"createjs","slug":"createjs","date":"2017-11-09T11:44:13.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/createjs/","link":"","permalink":"http://yoursite.com/2017/11/09/createjs/","excerpt":"","text":"常见的一些问题 加载不同域名的图片会报跨域的错误。 原因是什么？在canvas中引入了不是当前域名下的图片资源的时候， 如果我们没有设置图片的crossOrigin属性， 并且服务器端没有返回正确的头信息（Access-Control-Allow-Origin:xxx|*）的话 ，我们的canvas就会被污染（trained）,这样的结果就是我们在使用canvas中的getImageData 等操作canvas图片信息的时候会报错。根本问题是安全问题！！！ 如何解决设置crossOrigin属性，服务器端返回头中添加正确的头信息。 默认情况下，如果我们不设置图片的这个属性的时候 就会存在trained的问题 如果填写img.crossOrigin = ‘anonymous’ 并且服务器端能够支持这种请求，添加了相关的头信息， 那么就不会出现tained的问题 ， 我们就能正常使用了。 如果填写的是img.crossOrigin = ‘use-credentials’ 那么服务器端那边就需要返回相关的证书 如果我们填写的是除了anynomous 和use-credentials 两者之外的值 就会被当做是anonymous值来处理。 在createjs中，我们如果有操作canvas信息的方法调用就需要设置成如下1var loader = new createjs.LoadQueue(false, &apos;&apos;, &apos;anonymous&apos;)//false 如果是没有那些操作就可以直接写成：1var loader = new createjs.LoadQueue(false) 声音播放有很多问题 需要总结 避免： 自动播放音乐使用 howler.js 试试","categories":[],"tags":[{"name":"cratejs","slug":"cratejs","permalink":"http://yoursite.com/tags/cratejs/"},{"name":"audio","slug":"audio","permalink":"http://yoursite.com/tags/audio/"}]},{"title":"格式化银行号码","slug":"js-format-number","date":"2017-11-09T11:42:42.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/js-format-number/","link":"","permalink":"http://yoursite.com/2017/11/09/js-format-number/","excerpt":"","text":"需求： 用户输入银行卡号的时候 将银行卡号每四个数字之间加上一个空格 ， 并且保证光标位置正确（比如用户可能从中间位置插件数字） 功能点： 格式化 中间位置输入 光标位置定位问题 格式化123456//正则：var formatReg = /(\\d&#123;4&#125;)(?=\\d)/g;var val = this.value;var newVal = val.replace(/\\s/g, &apos;&apos;).replace(formatReg, &apos; &apos;); 光标位置定位问题12345678910111213141516171819如果我们直接给input赋值的话 ， 它的光标默认会调到最后，这样，当我们想在之间位置插入数字的时候，光标总会跑到最后，需要我们重新定位光标w3c =&gt;this.selectionStart = selectionEnd = pos;//如何计算pos呢？我们的输入值长度变换主要是因为空格引起的， 只需要计算出我们光标之前空格的变化+原来的光标位置就行了var startPos = this.selectionStart;//原始值得空格数量var originalSp = (this.value.slice(0, startPos).match(/\\s/)||[]).length;//格式化var newVal = this.value.replace(/\\s/g, &apos;&apos;).replace(formatReg, &apos; &apos;);//格式化后的空格var curSp = (newVal.slice(0, startPos).match(/\\s/)||[]).length;//新的位置var pos = startPos + curSp - originalSp;this.selectionStart = selectionEnd = pos; 完整的示例123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; &lt;title&gt;使用正则格式化&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;银行卡号&lt;/p&gt; &lt;input type=&quot;tel&quot; name=&quot;&quot; style=&quot;width: 400px;&quot;&gt;&lt;/body&gt;&lt;script type=&quot;text/javascript&quot;&gt; var input = document.querySelector(&apos;input&apos;); //输入的时候 获取当前的值 怎么回填 var length = 0; var lastAdd = false; input.oninput = function(e)&#123; var val = e.target.value; var posStart = this.selectionStart; //原始值的光标之前的空格数 var originalSp = (val.slice(0, posStart).match(/\\s/g)||[]).length; var newVal = val.replace(/(\\d&#123;4&#125;)(?=\\d)/g, &apos;$1 &apos;); //替换完成之后的空格 var curSp = (newVal.slice(0,posStart).match(/\\s/g)||[]).length; e.target.value = newVal; //this.setSelectionRange(posStart, res.length) this.selectionStart = this.selectionEnd = posStart +curSp -originalSp; //console.log(res) &#125;&lt;/script&gt;&lt;/html&gt;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"抽象语法树","slug":"js-syntax-tree","date":"2017-11-09T11:41:57.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/js-syntax-tree/","link":"","permalink":"http://yoursite.com/2017/11/09/js-syntax-tree/","excerpt":"","text":"AST （abstract syntax tree） 官方描述： 是源代码的抽象语法结构的树状表现形式简单的来说，就是js代码的map描述（普通的js对象） (项目git地址)[https://github.com/webaifei/ast-examples] 能做什么？ 抽象语法树的用处非常多，比如我们常见的代码压缩（之前我天真的以为代码压缩应该就是正则匹配替换掉换行和空格，在一次使用uglifyjs压缩代码测试的时候，发现一个没有用到的函数声明在压缩后的代码中彻底没找到！！），IDE的代码提示，错误提示，编译器等等。 就拿上面的我遇到的问题来说，它是怎么实现的检测到我定义了这个函数，但是没有使用呢。其实内部原来就是把整个代码解析成一棵树，包含了各种类型的节点，类似于我们熟悉的dom树（这点来看，其实很多技术的思想都是相通的） 我是在研究yeoman生成器mock-server的时候，需要修改已经存在的文件内容，遇到这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//AST&#123; &quot;type&quot;: &quot;Program&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;FunctionDeclaration&quot;, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;sau&quot;//函数名 &#125;, &quot;params&quot;: [], &quot;defaults&quot;: [], &quot;body&quot;: &#123; &quot;type&quot;: &quot;BlockStatement&quot;, &quot;body&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclaration&quot;, &quot;declarations&quot;: [ &#123; &quot;type&quot;: &quot;VariableDeclarator&quot;, &quot;id&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;inner&quot; &#125;, &quot;init&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;answer&quot; &#125; &#125; ], &quot;kind&quot;: &quot;var&quot; &#125; ] &#125;, &quot;generator&quot;: false, &quot;expression&quot;: false &#125;, &#123; &quot;type&quot;: &quot;ExpressionStatement&quot;,//节点类型 &quot;expression&quot;: &#123; &quot;type&quot;: &quot;CallExpression&quot;, &quot;callee&quot;: &#123; &quot;type&quot;: &quot;Identifier&quot;, &quot;name&quot;: &quot;sau&quot;//调用的函数名 &#125;, &quot;arguments&quot;: [] &#125; &#125; ], &quot;sourceType&quot;: &quot;script&quot;&#125; tree结构 1234tree - node - node ... tree根节点结构 123456&#123; type:&apos;Program&apos;, body:[ ]&#125; node 结构 1234567&#123; type:&apos;xxx&apos;, body:[ ], ...&#125; 除了变量node，其他的大概都有的两个属性 type body 除了type，body两个属性 每个节点上还包含了很多其他描述属性。比如：我们的函数声明node中包含一个id.name 就是我们的函数名， 而函数调用中有个expression.callee指向调用的函数名，我们只需要遍历整个树，查看定义的node 的id.name 在expression.callee中是否存在 就能知道我们的这个函数是否被调用过，如果没有调用过 我们就可以把这个函数定义的node删除掉！然后再把抽象语法树转换成js代码就ok了 上面的实现中，有三个比较重要的步骤 js =&gt; ast 遍历ast 修改 ast =&gt; js 如何把js解析成语法树这里，个人能力的缘故还不到去关注js＝&gt;ast转换的实现细节的时候，我们只要能实现就行，比较流行的有两个库： esprima 把js转换成ast esprima-fb 来自facebook,基于esprima 兼容jsx js|jsx =&gt; ast demos: esprima-fb/ js2ast.js =&gt; js解析成ast js2ast-with-options.js 通过配置不同的解析参数 ［在线查看不同配置参数的解析结果］(http://esprima.org/demo/parse.html) 遍历ast树 estraverse esprima-walk demos: esprima-walk walk.js 操作ast树 生成的抽象语法树 是一个js对象 所以对树的操作 就和修改普通的js对象一样 demos: escodegen-wallaby/ gen.js 修改tree属性 重新生成js代码 保存 ast转换成js escodegen escodegen-wallaby 兼容jsx 对应上面的esprima-fb","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"阻止表单默认行为","slug":"js-form","date":"2017-11-09T11:41:09.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/js-form/","link":"","permalink":"http://yoursite.com/2017/11/09/js-form/","excerpt":"","text":"使用添加属性的方式绑定事件 有下面的两种方法 1234form.onsubmit = function (e)&#123; e.preventDefault();//method 1 return false;// 2&#125; 使用addEventListener添加的事件 只有一种方式 123form.addEventListener(&apos;submit&apos;, function (e) &#123; e.preventDefault(); &#125;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"正则实战","slug":"reg2","date":"2017-11-09T11:40:30.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/reg2/","link":"","permalink":"http://yoursite.com/2017/11/09/reg2/","excerpt":"","text":"实战 纸上得来终觉浅 绝知此事要躬行 下面的实例都是简单的校验（前端一般够用） 手机号 123// 规则：/*纯数字 1开头 第二位34578 总共11位*/var telReg = /^1[34578]\\d&#123;11&#125;/ qq号 123//规则：/*纯数字 非0数字开头 最少4位*/var qqReg = /^[1-9]\\d&#123;4,&#125;/ 邮箱 123//规则：xxx@xx.xxx/*1. 肯定包含一个@ 2. 只能是字母数字，_- . */var qqReg = /^[\\w\\.-]+@[\\w\\.-]+\\.[a-z\\.]&#123;2,6&#125;/ 匹配url地址 123//规则：/*1. 以http:// https:// 开头 2. */var urlReg =/^https?:\\/\\/[\\w-]+\\.[a-z]&#123;2,6&#125;.*/ 身份证号 12//规则：15或18位数字 或者 17位数字＋X|xvar identifyReg = /(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;[\\dXx]$)/ 一段html代码 替换style=”xxx”为空 1var styleReg = /\\bstyle=&quot;[^&quot;]*&quot;/g 把url解析成一个对象 123456789101112// http://www.qq.com/index.html?key1=1&amp;key2=2/** &#123; protocol: &quot;http&quot;, hostname: &quot;www.qq.com&quot;, pathname: &quot;index.html&quot;, query: &quot;key1=1&amp;key2=2&quot; &#125; */var urlReg = /^(https?):\\/\\/([\\w-\\.]+\\.[a-z]&#123;2,6&#125;)\\/([\\w-\\.]*)\\?([\\w-=&amp;]*)/gurlReg.exec(&quot;http://www.qq.com/index.html?key1=1&amp;key2=2&quot;)//[&quot;http://www.qq.com/index.html?key1=1&amp;key2=2&quot;, &quot;http&quot;, &quot;www.qq.com&quot;, &quot;index.html&quot;, &quot;key1=1&amp;key2=2&quot;]","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"正则基础","slug":"reg","date":"2017-11-09T11:39:51.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/reg/","link":"","permalink":"http://yoursite.com/2017/11/09/reg/","excerpt":"","text":"正则表达式是什么？ regular expression 描述匹配否和一定规则的字符串 是一种规则描述 用来匹配字符串 工具： https://regexper.com 正则基础 原意字符就是本身的含义： a=&gt;a 元字符，在正则表达式中有特殊含义的非字母字符: ? + * $ ^ | \\ . + () {} [] 字符类 书写格式 匹配含义 . 任意字符 /d 数字，和[0-9]效果一样 /D 非数字，和[^0-9] 效果一样 /w 字母和下划线 [a-zA-Z_] /W 非字母和下划线 [^a-zA-Z_] /b 单词边界 /B 非单词边界 /s 空格 tab 等 ^xx 以xx开头 xx$ 以xx结束 - 从哪到哪: [a-z] [] 或 [abc] ,a 或b或c () 分组 量词 书写格式 匹配含义 * 任意次 + 至少一次 ? 一次或者0次 {n} 正好n次 {n,} 至少n次，注意逗号后面不能有空格 {0,n} 至多n次 {n,m} 至少n次， 至多m次 贪婪模式 和 非贪婪模式贪婪模式，尽可能多的匹配 ，如：12var reg = /\\d&#123;3,6&#125;/&quot;23344444&quot;.replace(reg, &apos;&apos;) // 44 如果我只是想实现 在现3-6数字 把前三个数字替换成空呢12var reg = /\\d&#123;3,6&#125;?/&quot;23344444&quot;.replace(reg, &apos;&apos;) // 44444 分组将几个字符作为单元进行匹配1234//匹配 连续出现3次ngnice的字符串var reg = /ngnice&#123;3&#125;/ //error匹配结果=&gt; ngniceeevar reg = /(ngnice)&#123;3&#125;/ //right 分组中的反向引用，即我们可以把分组捕获的值当作一个变量来引用 123//2015-05-11 =&gt; 11/05/2015var reg = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/&quot;2015-05-11&quot;.replace(reg, &apos;$3/$2/$1&apos;) 忽略分组12345var reg = /(\\d&#123;4&#125;)-(?:\\d&#123;2&#125;)-(\\d&#123;2&#125;)/&quot;2015-05-11&quot;.replace(reg, &apos;$3/$2/$1&apos;)$1 =&gt; 2015$2 =&gt; 11$3 =&gt; $3 //没有捕获就是字符串本身 正则前瞻匹配 （这里的前 指的是xx的后面） 所以它的作用就是找到后面紧跟的是xxx的xxx123现在我们有个需求，匹配下面字符串中的“的”，并且是后面有“中国”两个字。var str = &quot;美丽的华山，美丽的中国！&quot;;str.search(/的(?=中国)/)","categories":[],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"js解析过程","slug":"javascript-context","date":"2017-11-09T11:38:59.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/javascript-context/","link":"","permalink":"http://yoursite.com/2017/11/09/javascript-context/","excerpt":"","text":"js解析执行过程分为两步： 预解析 切换执行上下文 把［var声明的变量］和［function声明的函数］放到执行上下文(context)的变量对象(variables object)上，说白了就是创建存储空间。如果是在c等静态类型语言中， 我们在使用一个变量或者是函数之前 必须先声明 才能使用， 然而在js中 我们却可以在声明之前使用，其实这就是预解析的作用。 1234567alert(name) //undefined 不会报错var name = &apos;ngnice&apos;;say();//hello 不会报错function say()&#123; console.log(&apos;hello&apos;)&#125; 执行js代码完成预解析之后， 才真正的开始执行代码， 所以上一步的操作 很像是把我们可能不规范的代码格式化成类似c（先声明，后使用）的规范的代码 这两个过程 在js加载完成之后的初始化执行，函数调用，eval执行都会发生 1234567var name = &apos;ngnice&apos;;function say()&#123; var name = &apos;inner&apos;; console.log(name)&#125;say() 上面的代码执行的时候：先创建一个活动对象（预解析，规范化） 1234VO =&#123; name:undefined, say: function say()&#123; ... &#125;&#125; 执行代码 12name = &apos;ngnice&apos;//赋值say()//函数调用 还记得吗 函数调用的时候也会进行上面的两个操作 1234567//预解析 声明变亮VO=&#123; name: undefined&#125;//代码执行name = &apos;inner&apos;;//赋值console.log(name)//输出inner 参考： http://www.cnblogs.com/yupeng/archive/2012/04/08/2437959.html 实战： 面试题112345678function fn(a) &#123; console.log(a); var a = 2; function a() &#123;&#125; console.log(a);&#125;fn(1) 执行fn时候： 进入fn函数的执行上下文， 创建VO对象（函数中等同于AO） 12345VO=&#123; arguments:&#123; 0:function a()&#123;&#125; &#125;&#125; 执行 123console.log(a) //function a()&#123;&#125;a = 2 //赋值console.log(a) //a 结论： 参数赋值发生在预解析阶段，即：在预解析完成之后，参数的值就是参数的值 如果函数内部有和参数同名的函数声明 就会对参数的值进行修改；实际的效果就是同名的函数声明会覆盖掉实参的值（函数声明优先规则） 函数内部和参数同名的变量 是参数的不同引用地址 如果内部有和参数同名的变量声明 则不会对VO的同名属性造成影响","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"执行上下文","slug":"javascript-exc","date":"2017-11-09T11:38:22.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/javascript-exc/","link":"","permalink":"http://yoursite.com/2017/11/09/javascript-exc/","excerpt":"","text":"执行上下文 每当控制器进入ECMAscript可执行代码的时候，控制器就进入了一个可执行上下文。可执行上下文（简称EC）是一个抽象的概念，在ECMA262中用他来区分不同类型的可执行代码12我们定义一个可执行上下文的堆栈用数组表示ECStack = [] 可执行代码的类型： js加载完成之后的初始化（就是我们平时放到最外层，window下执行的代码）会创建一个 123ECStack = [ globalContext]; 函数执行 会把当前函数的执行上下文压入栈中，执行完成之后 再出栈销毁 12345678910//执行 pushECStack = [ globalContext, functionContext];//执行后 popECStack = [ globalContext, functionContext]; eval 也会形成执行上下文 实例分析： 123456789var name = &apos;ngnice&apos;function outer()&#123; function inner()&#123; console.log(name) &#125; inner();&#125;outer() 上面的代码执行的过程中的上下文变化： 脚本加载完成初始化 123ECStack = [ globalContext] 执行outer函数 12345//push outerContextECStack = [ globalContext, outerContext] 执行inner函数 123456//push innerContextECStack = [ globalContext outerContext, innerContext,] 执行完毕inner 12345//pop innerContextECStack = [ globalContext, outerContext] 执行完毕outer 1234//pop outerContextECStack = [ globalContext] 参考： http://www.cnblogs.com/yupeng/archive/2012/04/07/2436616.html","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"前端乱码问题","slug":"bianmawenti","date":"2017-11-09T11:37:25.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/bianmawenti/","link":"","permalink":"http://yoursite.com/2017/11/09/bianmawenti/","excerpt":"","text":"出现的原因乱码问题 其实就是“你说的我不懂！” 要说清楚乱码问题 首先，需要明白http协议http 协议简单理解就是客户端和服务端之间的一个约定。 其中的一个约定是关于传送内容的类型的： Content-Type服务器在返回响应的时候 会指定文件的类型：Content-Type 123456//图片类型Content-Type:image/png//js文件Content-Type:application/javascript;charset=UTF-8//这个类型 兼容老得掉牙的浏览器Content-Type:application/x-javascript Content-Type字段指定文件的类型同时还能指定浏览器要使用什么字符集进行解码 同时文件在生成的时候 我们也指定了文件的编码字符集。 所以会出现下面的两种情况： 服务器端指定的解码字符集和文件本身的编码字符集相同 ＝》结果：正确解析文件（没有乱码） 服务器端指定的解码字符集和文件本身的编码字符集不同＊ 如果解码字符集能够解析编码的字符集（类似英国人能够翻译美国人的话）文件正确解析（没有乱码）＊ 指定的解码字符集不能解析编码字符集（你丫的，我听不懂！） 于是，出现了乱码问题 好了，问题有了，怎么解决？？？ 指定正确的解码字符集 修改文件成服务器指定的字符集 文件内容修改成能够被解码（不改变编码字符集）啊哈 这个说的有点抽象 来个栗子： 123456//js文件我们使用汉字 编码格式 utf-8console.log(&apos;中国&apos;)//解码字符集指定为gb2312 －》出现乱码//修改文件内容 汉字＝》unicodeconsole.log(&apos;\\u4e2d\\u56fd&apos;) //我能行 我很行！ 下一节，去学习怎么使用js来把汉字转换成unicode字符 如何使用js来把汉字转成unicode编码 1234//转换成unicodeescape(str).toLocaleLowerCase().replace(/%u/gi,&apos;\\\\u&apos;);//转换成gb2312unescape(str.replace(/\\\\u/gi, &apos;%u&apos;)); 这里使用了两个函数 escape 和 unescape 1.escape 将字符转换成16进制字符串该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 后面的正则替换部分，后续！！后面的正则替换部分，后续！！ escape encodeURI encodeURIComponent 的区别 escape 不会对ASCII 字母和数字进行编码； 不会对ASCII - _ . ! ~ * ‘ ( )进行编码 encodeURI 不会对ASCII 字母和数字进行编码； 不会对ASCII - _ . ! ~ * ‘ ( )进行编码 不会对 ;/?:@&amp;=+$,# 进行编码 encodeURIComponent 不会对ASCII 字母和数字进行编码； 不会对ASCII - _ . ! ~ * ‘ ( )进行编码 但是会对 ;/?:@&amp;=+$,# 进行编码 但是会对 ;/?:@&amp;=+$,# 进行编码 但是会对 ;/?:@&amp;=+$,# 进行编码 escape 的功能和encodeURIComponent 比较相似，因为encodeURIComponent就是对uri的参数部分进行处理 适合的场景：我们在url中经常需要加上某个url作为参数 ，我们在解析这个url的时候会比较麻烦，因为在参数中同时包含了一个url；这个时候我们就可以使用 encodeURIComponent 对传入的url参数进行编码 总结： escape就是对字符串进行编码，如果涉及到url就不要使用这个， encodeURI 适合对整个url进行编码 encodeURIComponent 适合对作为参数的url进行编码","categories":[],"tags":[{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"webpack","slug":"webpack","date":"2017-11-09T11:36:27.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/webpack/","link":"","permalink":"http://yoursite.com/2017/11/09/webpack/","excerpt":"","text":"下面的是自己学习webpack的一些总结： 自我学习笔记总结 参考地址： 官网 虽然官网确实有些地方写的不是很清楚 但是应该是比较权威的 阮一峰老师的demo","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"node实现命令行工具","slug":"node-cmd","date":"2017-11-09T11:35:51.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/node-cmd/","link":"","permalink":"http://yoursite.com/2017/11/09/node-cmd/","excerpt":"","text":"环境变量linux下的常见目录和作用123456789101112131415161718192021222324/ --------根目录├── Applications --------mac下的程序存放目录├── Library├── Network├── System├── Users├── Volumes├── bin --------系统命令目录 （任何用户都能执行的命令）├── com.apple.mDNSResponder.plist.sonicwall.bk├── cores├── dev --------硬件文件目录├── etc -&gt; private/etc --------配置文件目录├── export├── home --------普通用户目录├── installer.failurerequests├── net├── opt├── private├── sbin --------系统命令目录 （只有root用户才能执行的命令）├── tmp -&gt; private/tmp├── usr ├── bin --------系统命令目录 （任何用户都能执行的命令） ├── sbin --------系统命令目录 （只有root用户才能执行的命令）└── var -&gt; private/var 需要注意的文件目录： bin 和 sbin 都是存放系统命令的地方 ；区别是sbin目录中的命令只有root用户才能执行 etc目录 是存放系统配置文件的目录， 比如hosts文件就在其中 linux 连接命令 link 12345678ln -s 软连接 (快捷方式)1. 拥有自己的i节点和block数据块（存储着数据 只不过存储的数据是原文件的i节点的指针）2. 删除了原文件的话 软连接是不能正常使用的 ；删除软连接的话 是不影响硬链接的使用的3. 创建软连接的话 源文件 需要指定绝对路径（如果不指定就会在当前目录下找）ln 硬链接 相同的i节点 相同的文件块 （可以认为是不同的指针指向同一个文件）1. 不能跨分区2. 不能针对目录 macOs 中添加环境变量的地方123451. 我们如果想在任何目录下使用我们的命令的话 就需要把我们的命令文件所在的绝对路径添加到环境变量中。2. 和windows系统比较像，macOs中也分为系统环境变量和用户变量3. /etc/profile (公有的 不论哪个用户登录的 都生效) /etc/bashrc (公有的 不论哪个用户登录的 都生效) ~/.bash_profile(个人用户中的配置 建议使用) 如何添加123456781. echo $PATH //查看当前的系统变量2. 打开 ~/.bash_profile 添加如下：# 定义一个HELLO变量export HELLO=/Users/ngnice/projects/fe-note/node-commond-line# 添加到$PATH中export PATH=$HELLO:$PATH3. 保存，退出。4. source .bash_profile (立即生效当前的修改， 默认是每次重启登录的时候读取) 文件的权限123456781. 执行ls -lsh8 -rw-r--r-- 1 ngnice staff 500B 1 13 11:06 PATH0 drwxr-xr-x 4 ngnice staff 136B 1 13 10:34 china8 -rw-r--r-- 1 ngnice staff 39B 11 5 20:13 file2.js0 drwxr-xr-x 4 ngnice staff 136B 1 26 2016 japan0 drwxr-xr-x 5 ngnice staff 170B 1 25 2016 nice8 lrwxr-xr-x 1 root staff 6B 1 13 11:47 soft-china -&gt; china/0 drwxr-xr-x 7 ngnice staff 238B 5 27 2016 src linux中的文件类型和权限分类12345678910-rw-r--r--上面的第一个“-”代表的是文件类型常见的 ：- -》普通文件d -》目录文件l -》软连接文件后面的9位 每三位一组 分别代表所有者，所有组，其他人权限r 代表 read （可读权限）w 代表 write （可写权限）x 代表 execute （可执行权限） linux 中如何修改文件（linux中一切皆文件）的权限 chmod u+x xxx//给xxx所有者添加可执行权限（增加） chmod g-r xxx //给xxx的所有组删除可读权限（删除） chmod o=rwx xxx//给xxx的其他人赋予所有权限（重新赋值） chmod 755 xxx//我擦嘞，这个是啥？ linux 中不同的权限可以使用不同的数字代表;r = 4 ,w=2,x=1;所以 chmod 755 xxx 的意思就是给xxx的所有者全部权限，给所有组读和执行权限，其他人也是读和执行权限","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"命令行","slug":"命令行","permalink":"http://yoursite.com/tags/命令行/"}]},{"title":"npm一些记录","slug":"npm","date":"2017-11-09T11:35:15.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/npm/","link":"","permalink":"http://yoursite.com/2017/11/09/npm/","excerpt":"","text":"npm设置淘宝源 12341.在项目根目录下新建 .npmrc写入：registry = https://registry.npm.taobao.org2. npm config set registry https://registry.npm.taobao.org npm发布包 报错 1234no_perms Private mode enable, only admin can publish this module: xxx修改npm源为 https://registry.npmjs.org 就行了npm config set registry https://registry.npmjs.org","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"}]},{"title":"一些不常用用的css写法","slug":"css","date":"2017-11-09T11:34:38.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/css/","link":"","permalink":"http://yoursite.com/2017/11/09/css/","excerpt":"","text":"font按照如下的顺序书写 font-style font-variant font-weight font-size/line-height font-family 其中 属性4、5必须同时书写，其他的属性可以缺少（使用默认值） *123456.title&#123; font: 18px/26px Arial;&#125;.titile-small&#123; font: 600 14px/26px Arial;&#125; 多行显示省略号 会使整个高度减少line-height 文字居中 下面会多出一个px","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"xml实体","slug":"xml","date":"2017-11-09T11:34:00.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/xml/","link":"","permalink":"http://yoursite.com/2017/11/09/xml/","excerpt":"","text":"xml中有些具有特定含义的字符，比如 &lt; 标记一个xml标签的开始。如果我们想要展示的是纯文本，而不想让解析器解析成标签的开始标记的话，我们就需要使用它的实体引用，否则会出现语法错误等情况。 xml中的实体引用","categories":[],"tags":[{"name":"xml","slug":"xml","permalink":"http://yoursite.com/tags/xml/"},{"name":"实体","slug":"实体","permalink":"http://yoursite.com/tags/实体/"}]},{"title":"h5-video","slug":"h5-video","date":"2017-11-09T11:31:09.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/h5-video/","link":"","permalink":"http://yoursite.com/2017/11/09/h5-video/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"浏览器解析过程","slug":"browser-md","date":"2017-11-09T11:29:52.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/browser-md/","link":"","permalink":"http://yoursite.com/2017/11/09/browser-md/","excerpt":"","text":"浏览器的组成浏览器就是请求资源 展示到用户面前 用户界面 UI 呈现引擎 负责显示请求的内容 网络 用于网络调用 用户界面后端 JavaScript 解释器 数据存储 页面解析过程 浏览器地址栏输入url DNS解析(DNS解析会查找浏览器的缓存，本地缓存等等) 浏览器使用网络模块发起请求 server返回html，下载完成 浏览器开始Parse HTML（解析一部分，就会渲染，并不是全部解析完成之后再去渲染） 浏览器发现一个加载css的外链， 发起一个请求加载这个样式表文件，期间（下载css文件和解析css文件期间）， 不阻塞Parse HTML（可以使用添加async的js脚本来验证）,但是因为css tree 没有构建完成，所以无法和DOM tree 一起构成render tree，后面的 layout, paint 也无法进行，所以文档后面内容无法展现到浏览器上 发现一个外链js文件，发起一个请求，去请求js,期间（下载js解析执行js脚本）会阻塞document的解析，所以会导致阻塞后面dom tree和后面的css tree的构建，最终导致阻塞 render tree的形成，所以浏览器上看不到显示（注意：这个时候现代浏览器都会启动另外的线程去解析剩余的document，去加载后面的外部资源，但是不会影响dom tree） 文件类型 是否阻塞后续DOM tree解析 是否阻塞后续 css tree 是否阻塞后续 render tree 是否影响最终展现屏幕上 备注 css样式 👍 👎 👎 👎 阻塞js的执行 js脚本 👎 👎 👎 👎 js的下载和执行会阻塞dom 解析，自然会阻塞css tree的解析， 但是现代浏览器都会启动另外的线程去解析剩下的dom，但是只会下载需要的资源 验证demo地址js脚本异步加载 使用defer属性 作用是：异步的加载js脚本 不会阻塞页面的渲染 会异步的加载 等到dom构建完成之后 再去执行脚本（异步的下载 dom之后执行） 使用async属性（html5新增） 不会阻塞页面的渲染 并且下载完成之后异步的解析执行（异步下载 异步执行） 同时拥有async 和 defer的时候 , async优先级高 css的解析 css解析规则 是从右向左 1div p em&#123;&#125; 另一方面，样式表的处理有这不同的模型。理论上来说，由于样式表不会改变dom结构，所以没有必要等待他们而停止文档解析。但是有一个问题：在文档解析阶段，脚本访问了样式信息，如果样式表没有下载完成，解析完毕，脚本将得到错误的答案，这样会引起很多问题。貌似是一个极端情况，却很常见。 firfox将会阻止所有的脚本，当还有没下载和解析的脚本时。 WebKit仅在用户尝试访问未加载样式表可能影响的某些样式属性时阻止脚本。 注意点1.http协议的网页加载https的外部资源（非跨域情况）都能无伤加载2.https协议的网页不能加载http的外部资源","categories":[],"tags":[{"name":"浏览器运行机制","slug":"浏览器运行机制","permalink":"http://yoursite.com/tags/浏览器运行机制/"}]},{"title":"history对比hash 【前端路由】","slug":"history-md","date":"2017-11-09T11:29:10.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/history-md/","link":"","permalink":"http://yoursite.com/2017/11/09/history-md/","excerpt":"","text":"pushState replaceState 对比hash切换 option h5 history hash 只要不去点击刷新或者重新载入页面不刷新页面 ✅ ✅ 都能够产生history历史记录 ✅ ✅ 能够分享出去连接 传播性 ✅ ✅ 是否能被爬虫 ✅（需要服务端对对应的路径进行相应） ❌ 服务端能够区别不同的请求路径 ✅ ❌ 页面刷新的时候 服务端能够匹配不同的路径 返回首屏数据 ✅ ❌ 页面刷新的时候 不需要服务端配置 ❌ ✅ 触发window的popstate事件 ❌不能 通过js调用history.back() forward才触发 ✅ hashchange事件 ❌ ✅ 是否能够操作history replace ✅ ❌ 总结下： history api 对搜索引擎更加友好； 操作history有更大的权限； 我们能够选择不保留某个历史记录（通过replaceState） 缺点是需要服务端的配合；hash更加的简单 前端能够通过hashchange 来判断不同的路由 进行不同的业务展示 注意点： window.onpopstate 事件的触发 在通过history.back history.forward 等能触发 在hash切换的时候也能触发","categories":[],"tags":[{"name":"前端路由","slug":"前端路由","permalink":"http://yoursite.com/tags/前端路由/"}]},{"title":"xml获取html, js ,css","slug":"jiqiao","date":"2017-11-09T11:28:24.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/jiqiao/","link":"","permalink":"http://yoursite.com/2017/11/09/jiqiao/","excerpt":"","text":"问题源于一个面试题： 通过xhr获取一html片段，其中包含html，css，js ，请问三种是否都能正常的解析执行？ 代码：12345678910111213141516171819202122232425var xhr = new XMLHttpRequest(); xhr.open(&apos;get&apos;, &apos;./hasjsHtml.html&apos;, true); xhr.onreadystatechange = function()&#123; if(xhr.status == 200 &amp;&amp; xhr.readyState ==4)&#123; console.log(xhr.responseText) document.getElementById(&apos;test&apos;).innerHTML = xhr.responseText; &#125; &#125; xhr.send(null)//请求的html片段&lt;style&gt;#sdf&#123; width: 100px; height: 100px; border: 1px solid #ccc;&#125;&lt;/style&gt;&lt;div id=&quot;sdf&quot;&gt; nice&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; alert(1)&lt;/script&gt; 结论： html，css样式都能够正常的解析和执行 js不能被执行","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"异步","slug":"异步","permalink":"http://yoursite.com/tags/异步/"}]},{"title":"居中布局","slug":"html2","date":"2017-11-09T11:27:39.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/html2/","link":"","permalink":"http://yoursite.com/2017/11/09/html2/","excerpt":"","text":"居中布局 不论是面试还是工作中 我们经常遇到的问题就是居中（水平 垂直居中） 外部容器固定高度 需要居中的元素也固定高度1因为都是固定值 所以能够通过设置固定值来定位， 不论是通过margin还是position等 外部容器高度不固定 内部元素的高度固定1234567891011/*(无兼容问题)*/.center&#123; width: 200px; height: 220px; background: #acb; position: relative; top: 50%;//把元素的左上角放到中心点 margin:0 auto;//水平居中 margin-top: -110px;//向上移动容器自身的一半&#125; 外部容器高度固定 内部容器高度不固定123456789101112/*(兼容问题) IE67不支持display:table-cell;*/.wraper&#123; display:table; /*需要设置宽高*/ width:xxx; height:xxx;&#125;.cell&#123; display: table-cell; vertical-align: middle; text-align: center;&#125; 12345678910/*使用css3 */.center4&#123; width: 50%; position: relative; /*拉倒中心*/ left: 50%; top: 50%; /*移动本身宽高的负1/2*/ transform: translate3d(-50%, -50%, 0)&#125; 使用vertical-align middle来实现图文垂直居中（类似flex的效果）1234567891011.list-item&#123; padding: 10px; /*如果设置了固定的高度 需要设置line-height来让vertical-align起作用 相应的内部元素都需要重新设置line-height*/&#125;.img&#123; vertical-align:middle;&#125;.desc&#123; display:inline-block; vertical-align: middle;&#125; 强大的flex布局123456789101112131415.flex&#123; display: flex; display: -webkit-flex; display: flex-box; justify-content: center;//水平居中 -webkit-box-align: center; -ms-flex-align: center; align-items: center;&#125;.flex-item&#123; flex: 1; -webkit-box-flex: 1; display: block;//兼容uc的bug&#125; 行内元素、块级元素、行内块级元素 类型 设置宽高是否有效 margin padding 行内元素 无效 上下无效，左右有效 有效 行内块级元素 有效 都有效 有效 行内块级元素 有效 都有效 有效 参考例子 em rem em相对单位， 相对于最近设置的font-size的值 rem相对于html上的font-size的值 css3 开启硬件加速使用 translate3d rotate3d rotate3d等属性可以开启GPU 硬件加速 参考地址","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"一些知识点","slug":"html","date":"2017-11-09T11:26:55.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/html/","link":"","permalink":"http://yoursite.com/2017/11/09/html/","excerpt":"","text":"写在前面总结了一些有用的面试知识点，没有什么规律 解决chrome不允许设置&lt;12px的字体问题 123456789101112//网上有好多这样的说法 然后我傻傻的去试了下 ： 我擦 骗我！// 继续百度 发现这个是在低版本的chrome（27）中可以使用 高版本已经禁用了html&#123; -webkit-text-size-ajust:none;&#125;// css3 使用transform:scale()来实现.f10&#123; font-size: 12px; transform:scale(0.875); transform-origin: left bottom;&#125; 网页布局之圣杯布局和双飞翼布局 首先明白一点，这两种布局概念的提出都是为了解决网页左中右三栏布局的问题 要求左右两栏固定宽度， 中间的内容宽度自适应 一般中间的内容很重要，需要优先解析展示 正常情况下，我们直接使用浮动就能够解决问题1 123456789101112131415161718192021/*css*/.container&#123;&#125;.left&#123; float:left; width: 200px; background:#f00;&#125;.right&#123; float: right; width: 150px; background:#ff0;&#125;.center&#123; padding: 0 150px 0 200px; background: blue;&#125;/*html 结构*/.container&gt;.left+.right+.center 上面的布局结构 能够解决问题1， 但是问题2却无法解决，改进方案(圣杯布局)：12345678910111213141516171819202122232425262728293031323334353637/*html structure*/&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center&quot;&gt;中间内容&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;导航&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;&lt;/div&gt;/*css*/div&#123; min-height: 100px;&#125;.container&#123; padding: 0 150px 0 200px;&#125;.left&#123; float:left; width: 200px; background:#f00; margin-left: -100%; z-index: 10; position: relative; left: -200px;&#125;.right&#123; float: left; width: 150px; background:#ff0; margin-left: -150px; position: relative; right: -150px;&#125;.center&#123; width: 100%; float: left; background: blue;&#125; 实现的主要原理： 通过margin-left 负值把left 和 right 部分拉到和center同列中 给外层的container设置padding 通过定位把left 和 right 定位到正确的位置上。 ps： 太诡异了 国内淘宝ued团队的双飞翼布局123456789101112131415161718192021222324252627282930313233343536373839/*html structure*/&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;inner&quot;&gt;我是中间&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/div&gt;/*css*/div&#123; min-height: 100px;&#125;.container&#123;&#125;.left&#123; float:left; width: 200px; background:#f00; margin-left: -100%;&#125;.right&#123; float: left; width: 150px; background:#ff0; margin-left: -150px;&#125;.center&#123; width: 100%; float: left; background: blue;&#125;.inner&#123; padding: 0 150px 0 200px;&#125; 主要解决思路 把中间的部分放到一个单独的div中 通过这个容器来设置padding 免去了设置定位 结构样式控制更加合理","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"网络层概述","slug":"network","date":"2017-11-09T11:26:05.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/network/","link":"","permalink":"http://yoursite.com/2017/11/09/network/","excerpt":"","text":"网络层应该向运输层提供怎样的服务？无连接的，可靠交付由端系统负责的数据报服务。 因为电信网的成功使用（电话服务），有人建议互联网也采用这种方式来实现。具体实现：需要通信的两端 先建立一个虚拟链接（占用一条通路），然后发送分组，通信结束后释放链接。 特点： 需要建立链接 不需要填写完整的目的主机地址，只需要填写虚电路的编号，节省了分组的开销。 分组无差错按序到达终点，不会存在丢失，重复的情况。 问题： 使用虚电路，利用率较低，会有很多的空闲时间被占用 容错，健壮性不好，如果建立的虚拟电路挂掉了，服务就无法送达。 单条通路容易出现阻塞。 价格昂贵（比如电信网程控交换机 复杂昂贵） 所有，人们提出另外的一种思路：网络层向上（运输层）提供简单灵活，无连接，尽最大努力交付的数据报服务。有一下的特点： 不需要建立连接 分组独立发送，不进行编号，不保证服务质量。 路由器比较简单 造价低廉（和电信网的交换机相比）","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"javascript 位运算","slug":"js-wei","date":"2017-11-09T11:24:28.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/js-wei/","link":"","permalink":"http://yoursite.com/2017/11/09/js-wei/","excerpt":"","text":"&amp; 按位与12341.判断奇偶数,原理就是 奇数二进制位最后一位一定为1 和 1做&amp; 运算一定是1 ，而偶数一定是0n&amp;12. | 或运算向下取正n|0","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"shell基础","slug":"shell","date":"2017-11-09T11:23:44.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/shell/","link":"","permalink":"http://yoursite.com/2017/11/09/shell/","excerpt":"","text":"shell基础变量声明12name=&quot;ngnice&quot;echo $name TIPS 直接变量 不需要其他的标识符标识是变量名称， 例如js中通过 var来定义变量 引用变量通过 $your_varaiable 赋值运算符前后不能有空格 运算1234567891011//比较特殊的是数值运算aa=1bb=2echo $aa+$bb//1+2 原封不动的输出 没有进行数值的加法运算//使用expr 但是需要注意+前后必须要有空格echo $(expr $aa + $bb) //3//使用 $(())来实现 I like it~echo $(($aa+$bb))//使用$[] 同样不错echo $[$aa+$bb]","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"}]},{"title":"nginx基础","slug":"nginx","date":"2017-11-09T11:23:02.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/09/nginx/","link":"","permalink":"http://yoursite.com/2017/11/09/nginx/","excerpt":"","text":"location匹配 按照匹配优先级顺序 = 精准匹配 完全匹配 比较适合匹配某个特定的路径12//只能匹配/index 其他的都不行，例如：/index/index.phplocation = /index ^~ 表示匹配普通字符串 前缀匹配 ~* 表示不区分大小写的正则匹配 ~ 表示区分大小写的正则匹配","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"vim常见命令","slug":"vim-cmd-md","date":"2017-11-08T06:22:21.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/vim-cmd-md/","link":"","permalink":"http://yoursite.com/2017/11/08/vim-cmd-md/","excerpt":"","text":"光标 回到上次编辑的位置 12ctrl + octrl + i mark书签 12345m+[a-zA-Z] //定义书签&apos;+[a-zA-Z] //跳转到指定的书签:marks //显示所有的书签:delm[a-zA-Z] //删除指定的书签:delm! //删除所有书签 打开文件 1234 //在指定行打开 vim +行号 file_name //在包含指定字符串的行打开vm+/xxxx file_name 在指定文件夹下 查找指定字符串 并且显示行号 1grep -rn xxx * 3.翻页ctrl+f//向下一页ctrl+b//向上一页ctrl+d//向下半页ctrl+u//想上半页 复制1yy //复制当前行 4.1 粘贴12p 在光标下一行粘贴P 在光标上一行粘贴 进入插入模式12345i 在光标之前插入a 在光标之后插入o 在当前行下一行插入新行6. 删除 dd 删除当前行","categories":[],"tags":[{"name":"vim","slug":"vim","permalink":"http://yoursite.com/tags/vim/"}]},{"title":"mac下配置LNMP环境","slug":"mac-lnmp-md","date":"2017-11-08T06:03:18.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/mac-lnmp-md/","link":"","permalink":"http://yoursite.com/2017/11/08/mac-lnmp-md/","excerpt":"","text":"安装nginx通过brew下载nginx 通过brew安装 通过 brew 安装nginx1brew install nginx 通过源码安装 安装wget 1brew install wget 下载nginx源码包 1wget http://nginx.org/download/nginx-1.8.0.tar.gz ./configure make sudo make install","categories":[],"tags":[{"name":"lnmp","slug":"lnmp","permalink":"http://yoursite.com/tags/lnmp/"},{"name":"mac","slug":"mac","permalink":"http://yoursite.com/tags/mac/"}]},{"title":"vituralbox 下 配置centos网络","slug":"linux-env-md","date":"2017-11-08T06:02:14.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/linux-env-md/","link":"","permalink":"http://yoursite.com/2017/11/08/linux-env-md/","excerpt":"","text":"遇到的问题 没有ifconfig 命令 通过yum install net-tools安装 没有网络 1234 可能网卡没有启动 service network restart， 设置开机自动启动vi /etc/sysconfig/network-scripts/ifconfig-xxxONBOOT=NO //改成YES 虚拟机配置的是动态ip 和本地ip不在一个网段 12将虚拟机网络设置 改成 “桥接网卡”重新启动 试试 4、 本机 ssh 连接虚拟机 提示 22端口 refused123456一般是因为 虚拟主机 防火墙 限制导致的centos7防火墙使用的是 firewall//使用如下命令添加访问权限firewall-cmd --permanent --add-port=22/tcpfirewall-cmd --reload //更新配置重新启动一个窗口 ssh连接（注意 如果还是在之前的窗口 可能一直不好使 ）","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"linux基础命令","slug":"linux-cmd1-md","date":"2017-11-08T06:01:19.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/linux-cmd1-md/","link":"","permalink":"http://yoursite.com/2017/11/08/linux-cmd1-md/","excerpt":"","text":"find 查找文件 注意点find 不支持正则表达式 只支持通配符find是完全匹配 符号 含义 * 匹配任意内容 ? 匹配任意一个字符 [] 匹配其中的任意一个字符 1234567891011121314151617//查找所有的文件find ./ -name &quot;*&quot;//查找以test开头的文件和文件夹find ./ -name test*//查找以test结尾的文件和文件夹find ./ -name *test//查找包含test的文件和文件夹find ./ -name *test*//查找当天创建的文件和文件夹 find ./ -ctime 0//查找1天之内创建的文件夹和文件find ./ -ctime -1//查找1天之前创建的文件件和文件find ./ ctime +1 grepgrep支持正则grep是模糊匹配（最大范围匹配）123456789//查看包含了test的行grep test//查看以test结尾的行grep test$//查看以test开头的行grep ^test//查看是test的行grep ^test$// 针对用户的操作12345678查看当前用户名who or whoami查看当前用户所在的用户组和组内其他成员groups user_name查看所有的用用户组cat /etc/group改变文件所属的用户组和用户名chown groupname:username file_name","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"centos下搭建LNMP环境","slug":"lnmp-md","date":"2017-11-08T05:59:55.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/lnmp-md/","link":"","permalink":"http://yoursite.com/2017/11/08/lnmp-md/","excerpt":"","text":"使用yum 安装nginx 添加nginx rpm依赖包 1rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm 使用yum 安装 1yum install nginx 启动nginx 1service nginx start // restart stop 2 如果发现访问 nginx 服务 被拒绝12345//可能是防火墙 没有允许对应的端口firewall-cmd --list-port //查看允许的端口//添加对应的web服务端口firewall-cmd --add-port=80/tcp --permanentfirewall-cmd --reload yum 安装mysql 参考这个教程即可http://www.cnblogs.com/julyme/p/5969626.htmlTIPS:教程中修改了mysql的密码 需要重新启动mysql服务 才能正常登陆。 yum 安装 php 源码方式安装12345wget http://hk1.php.net/get/php-7.1.11.tar.gz/from/this/mirrortar xzvf php-7.1.11./configure --prefix=/usr/local/php --enable-fpmmakemake install","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"lnmp","slug":"lnmp","permalink":"http://yoursite.com/tags/lnmp/"}]},{"title":"思考","slug":"note-md","date":"2017-11-08T05:57:36.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/08/note-md/","link":"","permalink":"http://yoursite.com/2017/11/08/note-md/","excerpt":"","text":"当下，前端火的一塌糊涂，从当年的切图工种成长为当前最为抢手的职业。也使得这个职业从当初的草莽转为王牌军。 前端领域最大的一个特点应该就是变化。 前一段时间可能还在流行angular，过几天大家又开始讨论react了；刚学会了grunt，gulp有兴起了，才开始学习gulp，其他人又开始玩webpack了，其他的开发同学都开玩笑，你们前端真是会玩！ 这些变化或者是新的技术框架是为了解决什么问题呢？相信大家都不会没事闲的整个框架完。我的理解是为了解决日益复杂的业务需求，为了适应当前业务中前端所承担的角色。 想想前端的洪荒时代，仅仅是为了处理表单更方便减轻服务器压力，而写几行js代码，我们也不需要什么模块管理工具，更用不到什么mvc，mvvm架构。 随着AJAX概念的出现，异步加载技术大大提升了web的用户体验，也为前端提供了更多的能力。Just remember: with great power comes great responsibility. 这样，随着前端承担越来越大业务，必然导致逻辑复杂性和代码复杂度以及代码的量增加，以前只需要几十行代码能搞定的事情，现在可能需要成千上万行实现。于是，n多浏览器的兼容性问题，全局变量，模块依赖，多人开发等问题，愈发凸显。prototype ,jquery 等库风行天下，cmd, amd 模块加载技术你挣我赶。再之后，大量业务逻辑和DOM操作混合杂糅，使得大型前端项目愈发艰难，难以为继。于是，开始借鉴后端的MVC思想来解决这种问题，backbone.js发力。结合前端特点，独辟蹊径，MVVM模式的框架入雨后春笋，angular,ember等等，风靡一时，react,vue更是独领风骚。加上 h5 history新的api 可以操作当前的path和监听path的改变使得前端路由不需要再担心SEO问题（hash的前端路由方式最大的问题就是对于SEO的支持问题），单页应用越发健壮。","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/笔记/"}]},{"title":"amd-cmd","slug":"amd-cmd","date":"2017-11-07T02:26:07.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/07/amd-cmd/","link":"","permalink":"http://yoursite.com/2017/11/07/amd-cmd/","excerpt":"","text":"","categories":[],"tags":[{"name":"模块加载","slug":"模块加载","permalink":"http://yoursite.com/tags/模块加载/"},{"name":"cmd","slug":"cmd","permalink":"http://yoursite.com/tags/cmd/"},{"name":"amd","slug":"amd","permalink":"http://yoursite.com/tags/amd/"}]},{"title":"实现自己的一个简单vuejs","slug":"mini-vue","date":"2017-11-06T10:56:39.000Z","updated":"2019-08-16T05:53:13.000Z","comments":true,"path":"2017/11/06/mini-vue/","link":"","permalink":"http://yoursite.com/2017/11/06/mini-vue/","excerpt":"","text":"我们将参考大神的一个demo 一步一步解读如何实现一个自己的小型vuejs","categories":[],"tags":[{"name":"mv*","slug":"mv","permalink":"http://yoursite.com/tags/mv/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]}]}