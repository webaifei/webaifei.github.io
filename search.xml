<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ios-视图导航</title>
      <link href="/2019/08/21/ios-navigator/"/>
      <url>/2019/08/21/ios-navigator/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果ViewController是分隔用户界面的载体，那么导航就是讲这些界面串联起来的工具</p></blockquote><h3 id="模态导航"><a href="#模态导航" class="headerlink" title="模态导航"></a>模态导航</h3><ol><li><p>打开一个新的视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 初始化视图控制器</span><br><span class="line">ModalViewController *modalVc = [[ModalViewController alloc] init];</span><br><span class="line">// 设置转场风格</span><br><span class="line">modalVc.modalTransitionStyle = UIModalTransitionStyleFlipHorizontal;</span><br><span class="line">// 执行导航</span><br><span class="line">[self presentViewController:modalVc animated:YES completion:nil];</span><br></pre></td></tr></table></figure></li><li><p>返回上一个视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 返回上一个视图</span><br><span class="line">[self dismissViewControllerAnimated:YES completion:nil];</span><br></pre></td></tr></table></figure></li><li><p>模态视图传值方式1 - 代理模式<br>本质上还是利用了代理实现在被代理者中调用代理者的方法的原理。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>oc中的代理模式</title>
      <link href="/2019/08/21/objective-c-daili/"/>
      <url>/2019/08/21/objective-c-daili/</url>
      
        <content type="html"><![CDATA[<blockquote><p>代理模式</p></blockquote><h3 id="如何实现代理者模式"><a href="#如何实现代理者模式" class="headerlink" title="如何实现代理者模式"></a>如何实现代理者模式</h3><ol><li><p>需要被代理的类在接口定义<code>@interface</code>中定义自己的协议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// xxx.h </span><br><span class="line">@protocol MyTabbarDelegate &lt;NSObject&gt;</span><br><span class="line">// 定义代理者需要实现的方法集合</span><br><span class="line">- (void)onClick:(MyTabbar *)mytabbar clickIndex: (NSInteger) index;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">// 类</span><br><span class="line">@interface MyTabbar : UIView</span><br><span class="line"></span><br><span class="line">@property (strong, nonatomic) NSArray *tabs;</span><br><span class="line">@property (nonatomic, strong) MyButton *lastSelectBtn;</span><br><span class="line">// 定义代理属性</span><br><span class="line">@property (nonatomic, weak) id&lt;MyTabbarDelegate&gt; delegate;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li><li><p>在被代理的类中触发代理 对应的事件信号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 如果代理者 实现了对应的方法</span><br><span class="line">if ([self.delegate respondsToSelector:@selector(onClick:clickIndex:)]) &#123;</span><br><span class="line">    [self.delegate onClick:self clickIndex:button.tag];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理者类设置要实现的协议，并且实现对应的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface TabViewController ()&lt;MyTabbarDelegate&gt;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 实现协议方法</span><br><span class="line">- (void)onClick:(MyTabbar *)mytabbar clickIndex:(NSInteger)index &#123;</span><br><span class="line">    NSLog(@&quot;cur index is %ld&quot;, (long)index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>lodash部分源码阅读</title>
      <link href="/2018/06/24/read-lodash/"/>
      <url>/2018/06/24/read-lodash/</url>
      
        <content type="html"><![CDATA[<blockquote><p>lodash 源码本身短小精悍 比较适合阅读，代码质量很高，涉及一些常见算法的应用。</p></blockquote><h3 id="函数方法"><a href="#函数方法" class="headerlink" title="函数方法"></a>函数方法</h3><h4 id="before"><a href="#before" class="headerlink" title="before"></a>before</h4><ol><li><p>调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//_.before(n, func);</span><br><span class="line">// 点击触发3次之后 将不再调用执行func</span><br><span class="line">$(dom).on(&apos;click&apos;, _.before(4, func));</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function before(n, func) &#123;</span><br><span class="line">  let result;</span><br><span class="line"></span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if(--n &gt;= 1) &#123;</span><br><span class="line">      result = func.apply(this, args);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      func = undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>知识点应用</p><ul><li>闭包保存参数n , func</li></ul></li></ol><h4 id="after"><a href="#after" class="headerlink" title="after"></a>after</h4><ol><li><p>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//_.after(n, func)</span><br><span class="line">// 在被调用n次的时候， 执行func</span><br><span class="line">var saves = [&apos;profile&apos;, &apos;settings&apos;];</span><br><span class="line"> </span><br><span class="line">var done = _.after(saves.length, function() &#123;</span><br><span class="line">  console.log(&apos;done saving!&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">_.forEach(saves, function(type) &#123;</span><br><span class="line">  asyncSave(&#123; &apos;type&apos;: type, &apos;complete&apos;: done &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function after(n, func) &#123;</span><br><span class="line"></span><br><span class="line">  return function (...args) &#123;</span><br><span class="line">    if(--n &lt; 0) &#123;</span><br><span class="line">      return func.apply(this, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>应用知识点</p><ul><li>使用闭包将n，func参数存储起来</li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 源码解读 </tag>
            
            <tag> lodash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数式编程</title>
      <link href="/2018/05/20/function-programimg/"/>
      <url>/2018/05/20/function-programimg/</url>
      
        <content type="html"><![CDATA[<h4 id="curry-柯里化"><a href="#curry-柯里化" class="headerlink" title="curry 柯里化"></a>curry 柯里化</h4><p><a href="https://hackernoon.com/currying-in-js-d9ddc64f162e" target="_blank" rel="noopener">https://hackernoon.com/currying-in-js-d9ddc64f162e</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js算法</title>
      <link href="/2018/05/20/js-algorithm/"/>
      <url>/2018/05/20/js-algorithm/</url>
      
        <content type="html"><![CDATA[<ol><li>求一个数组中最大的差值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1. 第一种实现方案：</span><br><span class="line">先排序，然后最大值-最小值</span><br><span class="line"></span><br><span class="line">2. 第二种实现方案：</span><br><span class="line">遍历过程中找到最大的差值</span><br><span class="line"></span><br><span class="line">function getMaxPro(arr)&#123;</span><br><span class="line"></span><br><span class="line">    var minPrice=arr[0];</span><br><span class="line">    var maxProfit=0;</span><br><span class="line"></span><br><span class="line">    for (var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line"></span><br><span class="line">       var currentPrice=arr[i];</span><br><span class="line"></span><br><span class="line">       minPrice=Math.min(minPrice,currentPrice);</span><br><span class="line"></span><br><span class="line">      var potentialProfit =currenrPrice-minPrice;</span><br><span class="line"></span><br><span class="line">       maxProfit=Math.max(maxProfit,potentialProfit);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     return maxProfit;  </span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web安全</title>
      <link href="/2018/05/19/web-safe/"/>
      <url>/2018/05/19/web-safe/</url>
      
        <content type="html"><![CDATA[<h3 id="常见的web安全问题"><a href="#常见的web安全问题" class="headerlink" title="常见的web安全问题"></a>常见的web安全问题</h3><h4 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h4><blockquote><p>跨站脚本攻击(Cross Site Script),为了和CSS区别，所以简称XSS</p></blockquote><p>XSS 利用网站没有对用户提交的数据进行转义处理或者过滤，导致恶意脚本被执行，最终用户的信息被窃取等严重后果</p><p>例子： 一个网站的评论功能没有对用户评论的内容没有进行过滤和处理，存储到了数据库中，然后直接展现到了页面中，执行了js代码，插入了一张华丽丽的图片引导用户点击到其他的站点，甚至将用户的信息，cookie的窃取</p><h4 id="CSRF-跨站请求伪造"><a href="#CSRF-跨站请求伪造" class="headerlink" title="CSRF (跨站请求伪造)"></a>CSRF (跨站请求伪造)</h4><blockquote><p>利用用户对于目标站点的信任，引诱或者在用户不知情的情况下，通过利用网站验证的漏洞（简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。）</p></blockquote><p>例子：</p><ol><li><p>假如一家银行用以执行转账操作的URL地址如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</span><br></pre></td></tr></table></figure></li><li><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p></li></ol><p>所以，需要具备以下的条件就会CSRF得逞</p><ol><li>用户登录了信任网站</li><li>session未过期，用户这个时候访问了其他的站点，这个站点中包含了一个请求信任站点某个接口（例如转账、关注等），而这些接口也没有其他的认证措施，导致信任网站受到攻击。</li></ol><p>防范措施：</p><ol><li>referer字段验证</li><li>添加token校验</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MV*架构</title>
      <link href="/2018/05/19/mvvm/"/>
      <url>/2018/05/19/mvvm/</url>
      
        <content type="html"><![CDATA[<p>前端的洪荒时代只是提供表单提交验证等简单的功能，随着异步加载技术的出现，前端在客户端&lt;=&gt;服务器交互中扮演的角色越来越重要，其最终的目的是为用户提供更优的体验，同时也促进了前端职业化进程（我们不再只是切图仔！）在CS结构向桌面应用程序接近的同时，越来越复杂的业务逻辑使得前端人员开始思考将桌面应用的思想搬到前端实践中。</p><blockquote><p>复杂的程序设计 必须有清晰合理的架构， 否则很难开发和维护</p></blockquote><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p> 应该是应用最广的架构模式了吧，或者说是最基本的架构模式，很多其他的模式都是基于它衍生而来。<br>    MVC 大家都了解， Model+View+Controller, 离用户最近的是View，这里接受用户的操作，给出反馈，然后View把相关的操作交给Controller，Controller去影响Model，然后再反馈到View，特点就是通信是单向的。</p><p> 但是实际过程中，可能比较灵活，因为前端开发中很大的工作量都在操作DOM。<br> 早期比较火的MVC库有<a href="http://backbonejs.org/" target="_blank" rel="noopener">backbone.js</a></p><p> 当前火爆的<a href="https://reactjs.org/" target="_blank" rel="noopener">React</a> 以及 <a href="https://cn.vuejs.org/" target="_blank" rel="noopener">vuejs</a><br> 其实将React和vuejs列入MVC框架中，不太妥当，两者都是用于构架ui层（view），并不包含模块加载，路由，数据管理，异步等utils集合。</p><h3 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h3><p> 将C替换成了P （presenter），他像一个控制调度中心，和View、Model进行双向通信，但是，View和Model之间不发生通信，这样 整个业务逻辑都在P这一层。<br>  前端实现库<a href="http://riotjs.com/" target="_blank" rel="noopener">riotjs</a></p><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p> 将P改成了VM（viewModel），基本上和MVP相同，不同的地方是VM和View之间双向绑定。<br>    比较流行的如： <a href="https://angularjs.org/" target="_blank" rel="noopener">angular.js</a></p><h2 id="react-和-vuejs对比"><a href="#react-和-vuejs对比" class="headerlink" title="react 和 vuejs对比"></a>react 和 vuejs对比</h2><table><thead><tr><th>对比项</th><th>react</th><th>vuejs</th><th>备注</th></tr></thead><tbody><tr><td>组件化、声明式</td><td>🆗</td><td>🆗</td><td></td></tr><tr><td>模板语法</td><td>jsx</td><td>默认使用模板语法，也支持jsx</td><td></td></tr><tr><td>virtual dom + diff algorithm</td><td>🆗</td><td>🆗</td><td></td></tr><tr><td>组件性能优化</td><td>🆗</td><td>🆗</td><td>vue实现了自动依赖追踪技术，不需要手动的实现shouldComponentUpdate，更加容易，同时也更加依赖底层，自由度较低</td></tr><tr><td>服务端渲染</td><td>🆗</td><td>🆗</td><td></td></tr><tr><td>跨终端</td><td>🆗</td><td>🆗</td><td>相比而言 RN要比 Weex更加成熟</td></tr><tr><td>社区活跃度</td><td>🔆🔆🔆</td><td>🔆🔆</td><td>相比而言 react的社区更加活跃</td></tr><tr><td>脚手架</td><td>🔆</td><td>🔆🔆</td><td>相比而言 vue的脚手架做的更加完善</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> mv* </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http协议</title>
      <link href="/2018/05/19/http-protocal/"/>
      <url>/2018/05/19/http-protocal/</url>
      
        <content type="html"><![CDATA[<h3 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h3><p>http协议是应用层协议族中的一员，是web通信基础。http协议建立在TCP（TCP是网络传输层的一个协议）协议之上。</p><h3 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h3><p>http报文分为请求报文和响应报文，报文包含了起始行、首部、实体的主题三个部分，其中起始行和首部都是ASCII文本，主体部分可以是任意数据格式的数据块。</p><h4 id="请求报文格式"><a href="#请求报文格式" class="headerlink" title="请求报文格式"></a>请求报文格式</h4><ol><li>请求起始行：包含 请求方法、请求url、HTTP协议和版本</li><li>请求首部，以key: value形式的结构</li><li>空行（必须有）</li><li>请求实体：任意数据组成的数据块（可以是ASCII文本或者是二进制数据等等）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /home HTTP/1.1</span><br><span class="line">HOST: www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: max-age=100000</span><br><span class="line">Cookie: xxxx=sss;</span><br></pre></td></tr></table></figure></li></ol><h4 id="响应报文格式"><a href="#响应报文格式" class="headerlink" title="响应报文格式"></a>响应报文格式</h4><ol><li>响应起始行：包含 HTTP协议版本、响应状态码、原因短语</li><li>响应首部：以行分割的 key: value格式</li><li>响应实体<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 ok</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 1100</span><br><span class="line">Set-Cookie: name=ngnice;</span><br></pre></td></tr></table></figure></li></ol><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><p>GET,POST,HEAD,PUT,DELETE,OPTIONS,TRACE,<br>常见的是GET,POST,HEAD,OPTIONS</p><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><ol><li><p>200系列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">200 OK</span><br><span class="line">204 No Content (CORS跨域设置中针对 OPTIONS的请求有这个设置)</span><br></pre></td></tr></table></figure></li><li><p>300系列</p></li></ol><table><thead><tr><th>code</th><th>状态描述</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久重定向</td><td></td></tr><tr><td>302</td><td>Found</td><td>临时重定向</td><td>将来的请求还是使用老的URL</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向</td><td>将来的请求还是使用老的URL</td></tr><tr><td>304</td><td>Not Modified</td><td>协商缓存</td><td>1. 响应主体不返回内容 <br> 2. 必须是GET请求</td></tr></tbody></table><p>TIPS:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 如果是重定向的code 但是没有给Location首部字段 那么响应还是之前的（因为不知道重定向到了什么地方）</span><br><span class="line">2. 302和307都是告诉浏览器请求的资源临时重定向到其他的地址了，下次请求还是请求老的地址，区别是302在HTTP/1.0中使用，307是HTTP/1.1中使用的</span><br><span class="line">3. 302和307的另外一个表现是：如果客户端发起一个POST请求，服务器返回一个302或者307 ，客户端将使用GET方法请求重定向的地址</span><br></pre></td></tr></table></figure></p><ol start="3"><li>400系列</li></ol><table><thead><tr><th>code</th><th>状态描述</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>403</td><td>Forbidden</td><td>被服务器拒绝</td><td></td></tr><tr><td>404</td><td>Not Found</td><td>没有找到对应的资源</td><td></td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求的方法不支持</td><td></td></tr><tr><td>408</td><td>Time out</td><td>超时</td></tr></tbody></table><ol start="4"><li>500系列</li></ol><table><thead><tr><th>code</th><th>状态描述</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>500</td><td>Internal Server Error</td><td>一般是服务器代码出错</td><td></td></tr><tr><td>404</td><td>Not Found</td><td>没有找到对应的资源</td><td></td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求的方法不支持</td><td></td></tr><tr><td>408</td><td>Time out</td><td>超时</td></tr></tbody></table><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><p>关于http缓存header这个文章讲的不错[http缓存]</p>]]></content>
      
      
      
        <tags>
            
            <tag> http 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react最佳实践</title>
      <link href="/2018/05/18/react-practice/"/>
      <url>/2018/05/18/react-practice/</url>
      
        <content type="html"><![CDATA[<h3 id="react-最佳实践"><a href="#react-最佳实践" class="headerlink" title="react 最佳实践"></a>react 最佳实践</h3><ol><li><p>增加属性类型检测 代码的健壮性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">YourComponent.propTypes = &#123;</span><br><span class="line">  name: PropTypes.string</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>默认属性设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YourComponent.defaultProps = &#123;</span><br><span class="line">  name: &apos;Stranger&apos;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>使用 react-dev-tool 来检测</p></li><li>使用shouldComponentUpdate或者使用PureComponent实现性能优化</li><li><p>在constructor中绑定this</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 避免下面的用法</span><br><span class="line">&lt;a onClick=&#123;(e)=&gt;this.clickHandle(e)&#125;&gt;</span><br><span class="line">// 使用如下方法来实现</span><br><span class="line">constructor() &#123;</span><br><span class="line">this.clickHandle = this.clickHandle.bind(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用key，并且正确使用key帮助react提升性能</p></li></ol><p>注意不要给子组件的key设置为index 因为这样并没有解决我们的问题 </p><p>详见<a href="../react-diff-md">react diff 算法</a></p><ol start="7"><li>请把异步请求等side effect 操作 放到componentDidMount中<br>具体原因参考：<a href="https://daveceddia.com/where-fetch-data-componentwillmount-vs-componentdidmount/" target="_blank" rel="noopener">客户端请求应该放到什么地方</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react diff算法</title>
      <link href="/2018/05/18/react-diff-md/"/>
      <url>/2018/05/18/react-diff-md/</url>
      
        <content type="html"><![CDATA[<h3 id="diff-算法"><a href="#diff-算法" class="headerlink" title="diff 算法"></a>diff 算法</h3><blockquote><p>virtual dom技术 将我们的DOM树在内存中存放了一份JS的对象映射（js本身的执行效率很高，操作DOM的代价昂贵）</p></blockquote><h4 id="传统的树结构比较"><a href="#传统的树结构比较" class="headerlink" title="传统的树结构比较"></a>传统的树结构比较</h4><p>传统的将一颗树转换成另外一棵树的算法复杂度是O(n^3)(算法实现待研究)，那么我们现在有1000个dom节点的话，就是一亿次计算量</p><p><a href="https://github.com/webaifei/js-topics/blob/master/react-best-practice/on%5E3.html" target="_blank" rel="noopener">简单例子</a>中 只是一个简单的计算（一亿次）但是，平均耗时是2.4s，可以想象我们如果进行了更加复杂的逻辑处理会是什么情况~</p><h4 id="如何从O-n-3-实现O-n-算法"><a href="#如何从O-n-3-实现O-n-算法" class="headerlink" title="如何从O(n^3)实现O(n)算法"></a>如何从O(n^3)实现O(n)算法</h4><blockquote><p>基于两点假设</p><ol><li>Two elements of different types will produce different trees.（不同类型的元素将会产生不同的树）</li></ol></blockquote><ol start="2"><li><p>The developer can hint at which child elements may be stable across different renders with a key prop.(开发者可以通过为同一层的子节点添加唯一key属性来优化)</p></li><li><p>DOM节点在不同层级的位置调整操作很少，可以忽略不计，实际项目中我们的DOM操作基本上几种这几个方面</p><ol><li>显示，隐藏元素， 包含简单节点和复杂节点（比如列表页，切换到了详情页）</li><li>更改某个元素的样式</li><li>新增，删除，移动某个元素</li></ol></li></ol><h4 id="根据两个假设需要注意的事情"><a href="#根据两个假设需要注意的事情" class="headerlink" title="根据两个假设需要注意的事情"></a>根据两个假设需要注意的事情</h4><ol><li>相同的结构不要更改父节点的类型（千万不要这么干）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 当返回跳转地址的时候 </span><br><span class="line">&lt;a href=&#123;href&#125;&gt;</span><br><span class="line">  &lt;YourComponent/&gt; // 比较复杂的一个组件</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">// 没有返回跳转地址的时候</span><br><span class="line">&lt;p&gt;</span><br><span class="line">  &lt;YourComponent/&gt;</span><br><span class="line">&lt;/p&gt;</span><br></pre></td></tr></table></figure></li></ol><p>当然，如果你的子组件如果很简单的话，可以忽略这条</p><ol start="2"><li>为同一层级的子组件添加key属性</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// key属性一定是唯一不变化的</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><ol><li><p>Elements Of Different Types</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对不同类型的元素的比较，react处理策略根据假设1 直接销毁原来的元素，创建新的节点</span><br></pre></td></tr></table></figure></li><li><p>DOM Elements Of The Same Type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">针对同种类型的React DOM 元素，react比对两个元素的属性，找到属性不同的地方进行更新</span><br></pre></td></tr></table></figure></li><li><p>Component Elements Of The Same Type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">针对相同类型的组件元素，</span><br><span class="line"></span><br><span class="line">默认情况下，使用新的props和state 调用render 生成一颗新树， 然后和之前的树进行递归对比</span><br><span class="line"></span><br><span class="line">如果我们重写了shouldComponentUpdate或者是继承了 PureComponent ，那么就会根据作者的意图来选择是否执行render，生成一颗新树进行diff algorithm</span><br></pre></td></tr></table></figure></li><li><p>Recursing On Children（递归比较子组件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">经过上面3中比较之后，react就会对两棵树的children进行比较</span><br><span class="line"></span><br><span class="line">4.1 默认情况下，在递归一个DOM node 的 children的时候，react仅仅是同时遍历两个children的list，找到不同的节点进行对应的操作</span><br><span class="line">  1) 节点类型不同 直接删除原节点 添加新节点</span><br><span class="line">  2) 节点类型相同 属性不同 修改属性</span><br><span class="line">  3) 都相同那就不做修改</span><br><span class="line"></span><br><span class="line">对于在children列表非最后的位置插入新节点，可能会有如下的问题：</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">react在遍历新旧节点list的时候发现 都节点属性都变换了，所以会造成三个节点都被修改一次，并不能准确的知道我们只是在开始的位置插入了一个新的节点（而在dom操作中 这种插入操作又非常的常见）</span><br></pre></td></tr></table></figure></li></ol><p>4.2 未children 添加key属性<br>为了解决上面的问题，react支持通过添加key来进行优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li key=&quot;Connecticut&quot;&gt;Connecticut&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;Duke&quot;&gt;Duke&lt;/li&gt;</span><br><span class="line">  &lt;li key=&quot;Villanova&quot;&gt;Villanova&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">这样，react在遍历children的子元素的时候 可以通过key来确认这个节点到底是否发生了变化</span><br><span class="line"></span><br><span class="line">TIPS: </span><br><span class="line">请注意上面的写法，key并不是取数组的索引，因为那样的话，和没有增加key的结果一样，并不会帮助react意识到哪个节点发生了变化，哪些没有</span><br><span class="line">然后再实际开发中，这样的代码却随处可见</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>connectjs源码解读</title>
      <link href="/2017/11/25/connnect-js/"/>
      <url>/2017/11/25/connnect-js/</url>
      
        <content type="html"><![CDATA[<h3 id="connect基本思路"><a href="#connect基本思路" class="headerlink" title="connect基本思路"></a>connect基本思路</h3><ol><li><p>app.use方法入栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var app = connect();</span><br><span class="line">// 第一个中间件</span><br><span class="line">app.use(&apos;/app&apos;, function fn1(req, res, next)&#123;</span><br><span class="line">next();</span><br><span class="line">&#125;);</span><br><span class="line">// 第二个中间件</span><br><span class="line">app.use(&apos;/app/list&apos;, function fn2(req, res, next)&#123;</span><br><span class="line">next();</span><br><span class="line">&#125;)</span><br><span class="line">// app作为接收到请求的事件函数 被调用</span><br><span class="line">http.createServer(app).listen(3000)</span><br></pre></td></tr></table></figure><p> 执行第一个中间件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var route = &#123;</span><br><span class="line">route: &apos;/app&apos;,</span><br><span class="line">handle: fn1</span><br><span class="line">&#125;</span><br><span class="line">app.stack.push(route)</span><br></pre></td></tr></table></figure><p> 执行第二个中间件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var route = &#123;</span><br><span class="line">route: &apos;/app/list&apos;,</span><br><span class="line">handle: fn1</span><br><span class="line">&#125;</span><br><span class="line">app.stack.push(route)</span><br></pre></td></tr></table></figure></li><li><p>访问的时候 调用next出栈</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//访问路径是app</span><br><span class="line">/app</span><br><span class="line">app内部调用定义的next方法</span><br><span class="line">1. 出栈添加的中间件</span><br><span class="line">2. 查看当前中间件的route是否在当前的访问路径中 继续next 直到没有可以出栈的中间件为止</span><br></pre></td></tr></table></figure></li></ol><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">var EventEmitter = require(&apos;evnets&apos;).EventEmitter;</span><br><span class="line">module.exports = createServer;</span><br><span class="line">var proto = &#123;&#125;;</span><br><span class="line">function createServer ()&#123;</span><br><span class="line">function app (req, res, next)&#123;</span><br><span class="line">app.handle(req, res, next);</span><br><span class="line">&#125;</span><br><span class="line">merge(app, proto);</span><br><span class="line">merge(app, EventEmitter.prototype)</span><br><span class="line">app.stack = [];</span><br><span class="line">app.route = &apos;/&apos;;</span><br><span class="line">return app;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">proto = &#123;</span><br><span class="line">use: function (route, fn)&#123;</span><br><span class="line">// 参数处理</span><br><span class="line">// code here</span><br><span class="line">this.stack.push(&#123;</span><br><span class="line">route: route, </span><br><span class="line">handle: fn</span><br><span class="line">&#125;)</span><br><span class="line">//链式调用</span><br><span class="line">return this;</span><br><span class="line">&#125;,</span><br><span class="line">handle: function (req, res, next)&#123;</span><br><span class="line">var index = 0;</span><br><span class="line">var stack = this.stack;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function next(err) &#123;</span><br><span class="line">var layer = stack[index++];</span><br><span class="line"></span><br><span class="line">if(!layer) &#123;</span><br><span class="line">//all done</span><br><span class="line">// code here</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">var route = layer.route;</span><br><span class="line">var path = parseUrl(req).pathname || &apos;/&apos;;//获取当前请求路径</span><br><span class="line">//如果当前调用的中间件的route 和当前请求路径不匹配 则执行下一个中间件</span><br><span class="line">if(path.toLowerCase().substr(0, route.length) !== route.toLowerCase())&#123;</span><br><span class="line">return next(err);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">next(err);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TODO</p><ol><li>为啥每次修改 req.url</li><li>其他容错处理</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> connect.js </tag>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端模板实现</title>
      <link href="/2017/11/11/template-fe/"/>
      <url>/2017/11/11/template-fe/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一步一步实现自己的前端模板</p></blockquote><p>最终的调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function template(string, data)&#123;</span><br><span class="line">//code here</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var str = &apos;this is the &#123;&#123;name&#125;&#125;&apos;;</span><br><span class="line">template(str, &#123;</span><br><span class="line">name: &apos;allo&apos;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>如何实现变量替换呢? 这里用到了两个正则方法</p><ol><li><p>replace  方法返回一个由替换值替换一些或所有匹配的模式后的新字符串 (不会影响原来字符串)</p></li><li><p>exec 在一个指定字符串中执行一个搜索匹配。返回一个数据或者null </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var varReg =/\&#123;\&#123;([^\&#125;]+)?\&#125;\&#125;/g;</span><br><span class="line">//varReg.lastIndex 标记了下一次开始检索的位置 </span><br><span class="line">varReg.exec(str)</span><br><span class="line">[</span><br><span class="line">&apos;&#123;&#123;name&#125;&#125;&apos;,</span><br><span class="line">&apos;name&apos;,</span><br><span class="line">index: 22,</span><br><span class="line">input: &apos;this is the &#123;&#123;name&#125;&#125;&apos;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>遍历所有的匹配项 进行替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function template(str, data)&#123;</span><br><span class="line">var varReg = /\&#123;\&#123;([a-zA-Z_\$])+\&#125;\&#125;/g;</span><br><span class="line">var tpl = &apos;&apos;;</span><br><span class="line">while( match = varReg.exec(str) ) &#123;</span><br><span class="line">var replaceStr = match[0],</span><br><span class="line">replaceKey = match[1];</span><br><span class="line">tpl = str.replace(replaceStr, data[replaceKey]);</span><br><span class="line">&#125;</span><br><span class="line">return tpl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面的代码有些问题，并不能支持如下的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;</span><br><span class="line">info: &#123;</span><br><span class="line">title:&apos;title here&apos;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var str = &apos;this is the &#123;&#123;info.title&#125;&#125;&apos;;</span><br><span class="line">使用上面的函数执行 &#123;&#123;info.title&#125;&#125; 将不会被替换</span><br><span class="line">str.replace(str, data[info.title]);//</span><br></pre></td></tr></table></figure></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 前端模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git基本命令</title>
      <link href="/2017/11/09/git/"/>
      <url>/2017/11/09/git/</url>
      
        <content type="html"><![CDATA[<p>工作区－》暂存区－》本地仓库－》远程仓库</p><ul><li>clone已有的项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone project-git-url</span><br></pre></td></tr></table></figure><ul><li>初始化一个新的仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>把新增的文件添加到我们的暂存区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add xxx or .</span><br></pre></td></tr></table></figure><ul><li>把暂存区中的文件提交到本地仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m  &apos;some msg for this commit &apos;</span><br></pre></td></tr></table></figure><ul><li>推送到远程的仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//1 如果local_branch 不存在 会报错</span><br><span class="line">//2. 如果省略了冒号和后面的远程分支名 代表远程分支名和本地分支名一样</span><br><span class="line">//3. 如果远程分支名不存在的话 就会创建一个新的远程分支</span><br><span class="line">//4. 如果local_branch 没写 是一个空格 那么就会删除远程分支</span><br><span class="line">git push origin local_branch:remote_branch</span><br></pre></td></tr></table></figure><ul><li>我错误的提交了一些文件 怎么删除掉呢</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached xxx //从仓库中删除 而保留原文件</span><br><span class="line">git rm -f xxx //从仓库中和本地删除文件（文件真实的被干掉了！！）</span><br></pre></td></tr></table></figure><ul><li>使用git reset 来进行版本的回退</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commit_id(某次的版本号)</span><br><span class="line">//HEAD 表示的是当前版本 ^表示上一个版本</span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>*git log 来查看历史commit的记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">// 格式话输出</span><br><span class="line">git log --pretty=oneline</span><br></pre></td></tr></table></figure><ul><li><p>git reflog 用来显示之前的操作记录</p></li><li><p>git checkout – xxx</p></li></ul><ol><li>用来撤撤销add之后没有commit又进行的修改  满足两个条件： 1 add 了 2. 没有commit又进行了修改</li><li>用来找回 已经add过误删的文件</li></ol><ul><li>git checkout -t remote_branch // 用来从远程拉取指定分支 并且在本地新建同名分支 而且和远程分支已经关联</li></ul><p>添加远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin xxxx</span><br></pre></td></tr></table></figure><p>把本地仓库的代码推送到远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>分支管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git branch //列出所有分支</span><br><span class="line">git branch -r //列出远程分支</span><br><span class="line">git branch xxx//新建分支xxx</span><br><span class="line">git branch -d xxx删除分支</span><br><span class="line">git checkout xxx//切换到xxx分支</span><br><span class="line">git checkout -b xxx //新建分支并切换到xxx分支</span><br><span class="line">git merge xxx //合并xxx到当前分支</span><br></pre></td></tr></table></figure><p>配置别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>udp协议</title>
      <link href="/2017/11/09/network-udp/"/>
      <url>/2017/11/09/network-udp/</url>
      
        <content type="html"><![CDATA[<h3 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h3><blockquote><p> 运输层为它上层应用层提供服务。</p></blockquote><ol><li>互联网中的通信其实是在主机运行的应用进程进行的。</li><li>网际层实现的找到目的主机，交付ip数据报。</li><li>运输层是面向通信部分的最高层，也是用户功能的最底层，只有主机的协议栈中才有运输层。</li><li>运输层除了要把ip层交付的数据报交付给指定的进程，还要有分用和复用的功能。</li></ol><p>两个运输层协议：</p><ol><li>用户数据包协议（UDP）</li><li>传输控制协议</li></ol><blockquote><p>DUP 协议提供尽最大努力交付的服务。</p><ol><li>传输之前不需要建立链接，自然传输结束之后也不需要断开连接</li><li>不保证传输的可靠性</li><li>每次都将应用进程的传递过来的数据加上首部字段 传递给IP层，不对数据进行分割。可能导致IP层进行分片，增加ip层的开销，或者由于运输数据单元过小，导致IP层的利用率降低。</li><li>因为不需要考虑传输的可靠性，所以实现相对较简单，系统资源开销小。所以比较适合：对数据安全要求比较低，对响应速度要求很高，网络负担很重的case。</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ip协议</title>
      <link href="/2017/11/09/network-ip/"/>
      <url>/2017/11/09/network-ip/</url>
      
        <content type="html"><![CDATA[<blockquote><p>IP 协议是TCP/IP协议栈中非常重要的一个协议</p></blockquote><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ip 地址 由 32位二进制数字组成（IPV4版本），分成两个部分： 网络ID 和 主机ID</p><blockquote><p> 网络id 在整个互联网是唯一的，而主机id在所在的网络id中是唯一的， 这样每一个ip地址都是唯一的。</p></blockquote><h3 id="ip地址分类"><a href="#ip地址分类" class="headerlink" title="ip地址分类"></a>ip地址分类</h3><ol><li>A类地址： 网络id占用一个字节，首位固定0，可用编号 0-127</li><li>B类地址： 网络id占用两个字节，前两位固定10 ，可用编号 128-191</li><li>C类地址： 网络id占用三个字节，前三位固定110 ，可用编号 192-223</li><li>D类地址：多播</li><li>E类 研究</li></ol><h3 id="IP地址的结构为啥是分级组成"><a href="#IP地址的结构为啥是分级组成" class="headerlink" title="IP地址的结构为啥是分级组成"></a>IP地址的结构为啥是分级组成</h3><ol><li>方便管理，ip地址分配管理者只需要把网络id分配出去，即可，否则每一个主机的ip都需要分配的话，会死人的。</li><li>减少路由器内存，减少路由查询时间。不同的网络之间通信，通过路由器查询网络id来找到要送达的网络，而至于送到某个主机则由所在网络的路由器去完成，这样能很大程度上减少路由表的数据，减少路由查找时间。</li></ol><h3 id="ip地址为啥要分成这些类"><a href="#ip地址为啥要分成这些类" class="headerlink" title="ip地址为啥要分成这些类"></a>ip地址为啥要分成这些类</h3><ol><li>因为需求不一样，有些公司接入的主机很多，需要一个能容纳很多主机的ip地址，有些则需要比较少的ip地址。</li></ol><h3 id="ip数据报传输过程"><a href="#ip数据报传输过程" class="headerlink" title="ip数据报传输过程"></a>ip数据报传输过程</h3><ol><li>主机A发送数据报，本网络路由器查看路由表，目的主机B是否在同一网络，如果是同一个网络，那么就直接交付，不需要经过其他的路由器；如果不是，本网络路由器查找路由表找出下一跳的路由器，直到找到主机B所在网络的路由器，由它进行直接交付。</li></ol><blockquote><p>IP地址是逻辑上的地址，类似小明家这个概念。你去小明家肯定去的是一个具体的物理地址（坐标）。IP数据报在真正传输的过程中也需要找到目的主机IP地址对应的物理地址，才能交付。ARP（address resolution protocal）地址解析协议就是做这个工作的。对应的还有RARP（逆地址解析协议， 已经被DHCP协议替代）</p></blockquote><h3 id="ARP协议实现原理"><a href="#ARP协议实现原理" class="headerlink" title="ARP协议实现原理"></a>ARP协议实现原理</h3><ol><li>每一个主机都有一个ARP高速缓存（ARP cache），存储着各个主机和路由器的ip地址和硬件地址的映射表。那这个主机是怎么知道这些数据的呢？<br>利用广播的原理，当一次通信请求过来时候，需要找下一跳的目的主机，如果发现目的主机的ip地址和物理地址不在自己的cache中的时候 就自动运行ARP进程发出一个广播：我是主机A，IP地址是128.0.1.xxx (可能通过逆地址解析出来)，物理地址是xxx，想要找IP地址是128.0.1.xxx的硬件地址。</li><li>然后本局域网中的所有主机都会收到这个广播，发现找的是自己就记录下主机A的ip地址和物理地址（以备后用），并响应：我的IP是xxx，物理地址是xxx。</li></ol><h3 id="TIPS"><a href="#TIPS" class="headerlink" title="TIPS:"></a>TIPS:</h3><ol><li>高速缓存有生存周期，方便物理地址发生更改的时候，再次发起ARP广播，否则一直都是走cache 就over了。</li><li>ARP协议只是解决了局域网内ip地址到物理地址的转换。不同网络的传输，交给路由器来完成ARP解析。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http缓存</title>
      <link href="/2017/11/09/network-http/"/>
      <url>/2017/11/09/network-http/</url>
      
        <content type="html"><![CDATA[<p>http 协议是整个 互联网的基石之一。<br>是web开发者必须关注的一个协议。</p><p>关于http缓存header这个文章讲的不错<a href="http://louiszhai.github.io/2017/04/07/http-cache/" target="_blank" rel="noopener">http缓存</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
            <tag> 缓存 </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 进程管理</title>
      <link href="/2017/11/09/linux-process/"/>
      <url>/2017/11/09/linux-process/</url>
      
        <content type="html"><![CDATA[<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><blockquote><p>进程管理的首要目的是检查健康状况， 其次是进程管理：查找，终止</p></blockquote><ol><li><p>查看所有进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// a  显示现行终端机下的所有进程，包括其他用户的进程。</span><br><span class="line">// u 以用户为主的格式来显示进程状况</span><br><span class="line">// x 　显示所有进程，不以终端机来区分。</span><br><span class="line"> ps aux</span><br></pre></td></tr></table></figure></li><li><p>查看健康状况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure></li><li><p>终止进程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //强制终止进程</span><br><span class="line"> kill -9 pid</span><br><span class="line">//重新启动进程</span><br><span class="line">kill -1 pid</span><br></pre></td></tr></table></figure></li></ol><h2 id="工作管理"><a href="#工作管理" class="headerlink" title="工作管理"></a>工作管理</h2><blockquote><p>后台进程管理,只有程序运行期间不用用户参与的进程才能放入到后台（比如 mysql http服务等）</p></blockquote><ol><li><p>把进程放入后台</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_commond &amp;</span><br></pre></td></tr></table></figure></li><li><p>查看后台服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs</span><br><span class="line"></span><br><span class="line">//-l 显示进程号</span><br><span class="line">jobs -l</span><br></pre></td></tr></table></figure></li><li><p>放到前台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fg %工作号</span><br></pre></td></tr></table></figure></li><li><p>放到后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bg %工作号</span><br></pre></td></tr></table></figure></li></ol><h2 id="后台进程脱离终端"><a href="#后台进程脱离终端" class="headerlink" title="后台进程脱离终端"></a>后台进程脱离终端</h2><p>正常情况下，我们的进程在一个终端开启之后，如果关闭了当前的终端,终端会触发SIGHUP的信号，这样在当前终端绑定的进程就会被关闭<br>怎么能够脱离当前的终端呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 在文件中启动进程</span><br><span class="line"></span><br><span class="line">2. 使用nohub命令执行命令</span><br><span class="line">nohup http-server &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FTP协议</title>
      <link href="/2017/11/09/app-protocol/"/>
      <url>/2017/11/09/app-protocol/</url>
      
        <content type="html"><![CDATA[<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><blockquote><p>ftp(file transfer protocol)  文件传送协议 它屏蔽了各计算机系统的细节（各个计算机系统对文件系统的实现差异很大）</p></blockquote><p>不同系统的计算机互传文件经常遇到的问题：</p><ol><li>计算机存储的数据格式不同</li><li>文件的目录结构文件命名的规定不同</li><li>对于相同的文件存取功能，不同的系统使用的命令不同</li><li>访问控制方法不同</li></ol><p>FTP的主要功能就是减少或者消除在不同操作系统下处理文件的不兼容性。</p><p>ftp是基于tcp实现的，工作的原理：</p><ol><li>运行主进程监听 21端口（默认），等待客户链接</li><li>客户端请求链接</li><li>收到客户请求，分配从属进程处理客户端请求</li><li>处理完成之后 终止从属进程。</li><li>周而复始</li></ol><h2 id="TELNET"><a href="#TELNET" class="headerlink" title="TELNET"></a>TELNET</h2><blockquote><p>telnet 是一个远程终端协议<br>和ftp的工作原理比较类似，包含一个主进程和n个子进程</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>createjs</title>
      <link href="/2017/11/09/createjs/"/>
      <url>/2017/11/09/createjs/</url>
      
        <content type="html"><![CDATA[<h2 id="常见的一些问题"><a href="#常见的一些问题" class="headerlink" title="常见的一些问题"></a>常见的一些问题</h2><blockquote><p> 加载不同域名的图片会报跨域的错误。<br></p></blockquote><h3 id="原因是什么？"><a href="#原因是什么？" class="headerlink" title="原因是什么？"></a>原因是什么？</h3><p>在canvas中引入了不是当前域名下的图片资源的时候， 如果我们没有设置图片的crossOrigin属性， 并且服务器端没有返回正确的头信息（Access-Control-Allow-Origin:xxx|*）的话 ，我们的canvas就会被污染（trained）,这样的结果就是我们在使用canvas中的getImageData 等操作canvas图片信息的时候会报错。根本问题是安全问题！！！</p><h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>设置crossOrigin属性，服务器端返回头中添加正确的头信息。</p><ol><li>默认情况下，如果我们不设置图片的这个属性的时候 就会存在trained的问题</li><li>如果填写img.crossOrigin = ‘anonymous’ 并且服务器端能够支持这种请求，添加了相关的头信息， 那么就不会出现tained的问题 ， 我们就能正常使用了。</li><li>如果填写的是img.crossOrigin = ‘use-credentials’ 那么服务器端那边就需要返回相关的证书</li><li>如果我们填写的是除了anynomous 和use-credentials 两者之外的值 就会被当做是anonymous值来处理。</li></ol><p>在createjs中，我们如果有操作canvas信息的方法调用就需要设置成如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new createjs.LoadQueue(false, &apos;&apos;, &apos;anonymous&apos;)//false</span><br></pre></td></tr></table></figure></p><p>如果是没有那些操作就可以直接写成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var loader = new createjs.LoadQueue(false)</span><br></pre></td></tr></table></figure></p><blockquote><p> 声音播放有很多问题 需要总结 <br><br>避免： 自动播放音乐<br>使用 <a href="http://goldfirestudios.com/blog/104/howler.js-Modern-Web-Audio-JavaScript-Library" target="_blank" rel="noopener">howler.js</a> 试试</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> cratejs </tag>
            
            <tag> audio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化银行号码</title>
      <link href="/2017/11/09/js-format-number/"/>
      <url>/2017/11/09/js-format-number/</url>
      
        <content type="html"><![CDATA[<p>需求：</p><blockquote><p>用户输入银行卡号的时候 将银行卡号每四个数字之间加上一个空格 ， 并且保证光标位置正确（比如用户可能从中间位置插件数字）</p></blockquote><p>功能点：</p><ol><li>格式化</li><li>中间位置输入 光标位置定位问题</li></ol><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//正则：</span><br><span class="line">var formatReg = /(\d&#123;4&#125;)(?=\d)/g;</span><br><span class="line"></span><br><span class="line">var val = this.value;</span><br><span class="line"></span><br><span class="line">var newVal = val.replace(/\s/g, &apos;&apos;).replace(formatReg, &apos; &apos;);</span><br></pre></td></tr></table></figure><h3 id="光标位置定位问题"><a href="#光标位置定位问题" class="headerlink" title="光标位置定位问题"></a>光标位置定位问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">如果我们直接给input赋值的话 ， 它的光标默认会调到最后，这样，当我们想在之间位置插入数字的时候，光标总会跑到最后，需要我们重新定位光标</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w3c =&gt;this.selectionStart = selectionEnd = pos;</span><br><span class="line"></span><br><span class="line">//如何计算pos呢？</span><br><span class="line">我们的输入值长度变换主要是因为空格引起的， 只需要计算出我们光标之前空格的变化+原来的光标位置就行了</span><br><span class="line"></span><br><span class="line">var startPos = this.selectionStart;</span><br><span class="line">//原始值得空格数量</span><br><span class="line">var originalSp = (this.value.slice(0, startPos).match(/\s/)||[]).length;</span><br><span class="line">//格式化</span><br><span class="line">var newVal = this.value.replace(/\s/g, &apos;&apos;).replace(formatReg, &apos; &apos;);</span><br><span class="line">//格式化后的空格</span><br><span class="line">var curSp = (newVal.slice(0, startPos).match(/\s/)||[]).length;</span><br><span class="line"></span><br><span class="line">//新的位置</span><br><span class="line">var pos = startPos + curSp - originalSp;</span><br><span class="line">this.selectionStart = selectionEnd = pos;</span><br></pre></td></tr></table></figure><h2 id="完整的示例"><a href="#完整的示例" class="headerlink" title="完整的示例"></a>完整的示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br><span class="line">    &lt;title&gt;使用正则格式化&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;p&gt;银行卡号&lt;/p&gt;</span><br><span class="line">    &lt;input type=&quot;tel&quot; name=&quot;&quot; style=&quot;width: 400px;&quot;&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var input = document.querySelector(&apos;input&apos;);</span><br><span class="line">    //输入的时候 获取当前的值 怎么回填</span><br><span class="line">    var length = 0;</span><br><span class="line">    var lastAdd = false;</span><br><span class="line">    input.oninput = function(e)&#123;</span><br><span class="line">        var val = e.target.value;</span><br><span class="line">        var posStart = this.selectionStart;</span><br><span class="line">        //原始值的光标之前的空格数</span><br><span class="line">        var originalSp = (val.slice(0, posStart).match(/\s/g)||[]).length;</span><br><span class="line"></span><br><span class="line">        var newVal = val.replace(/(\d&#123;4&#125;)(?=\d)/g, &apos;$1 &apos;);</span><br><span class="line">        //替换完成之后的空格</span><br><span class="line">        var curSp = (newVal.slice(0,posStart).match(/\s/g)||[]).length;</span><br><span class="line"></span><br><span class="line">        e.target.value = newVal;</span><br><span class="line">        //this.setSelectionRange(posStart, res.length)</span><br><span class="line">        this.selectionStart = this.selectionEnd = posStart +curSp -originalSp;</span><br><span class="line">        //console.log(res)</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象语法树</title>
      <link href="/2017/11/09/js-syntax-tree/"/>
      <url>/2017/11/09/js-syntax-tree/</url>
      
        <content type="html"><![CDATA[<h2 id="AST-（abstract-syntax-tree）"><a href="#AST-（abstract-syntax-tree）" class="headerlink" title="AST （abstract syntax tree）"></a>AST （abstract syntax tree）</h2><blockquote><p>官方描述： 是源代码的抽象语法结构的树状表现形式<br>简单的来说，就是js代码的map描述（普通的js对象）</p></blockquote><p>(项目git地址)[<a href="https://github.com/webaifei/ast-examples]" target="_blank" rel="noopener">https://github.com/webaifei/ast-examples]</a></p><h2 id="能做什么？"><a href="#能做什么？" class="headerlink" title="能做什么？"></a>能做什么？</h2><blockquote><p>抽象语法树的用处非常多，比如我们常见的代码压缩（之前我天真的以为代码压缩应该就是正则匹配替换掉换行和空格，在一次使用uglifyjs压缩代码测试的时候，发现一个没有用到的函数声明在压缩后的代码中彻底没找到！！），IDE的代码提示，错误提示，编译器等等。</p></blockquote><p>就拿上面的我遇到的问题来说，它是怎么实现的检测到我定义了这个函数，但是没有使用呢。其实内部原来就是把整个代码解析成一棵树，包含了各种类型的节点，类似于我们熟悉的dom树（这点来看，其实很多技术的思想都是相通的）</p><p>我是在研究yeoman生成器<a href="https://github.com/webaifei/generator-mock-server" target="_blank" rel="noopener">mock-server</a>的时候，需要修改已经存在的文件内容，遇到这个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//AST</span><br><span class="line">&#123;</span><br><span class="line">  &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">  &quot;body&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;FunctionDeclaration&quot;,</span><br><span class="line">          &quot;id&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">              &quot;name&quot;: &quot;sau&quot;//函数名</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;params&quot;: [],</span><br><span class="line">          &quot;defaults&quot;: [],</span><br><span class="line">          &quot;body&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;BlockStatement&quot;,</span><br><span class="line">              &quot;body&quot;: [</span><br><span class="line">                  &#123;</span><br><span class="line">                      &quot;type&quot;: &quot;VariableDeclaration&quot;,</span><br><span class="line">                      &quot;declarations&quot;: [</span><br><span class="line">                          &#123;</span><br><span class="line">                              &quot;type&quot;: &quot;VariableDeclarator&quot;,</span><br><span class="line">                              &quot;id&quot;: &#123;</span><br><span class="line">                                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                                  &quot;name&quot;: &quot;inner&quot;</span><br><span class="line">                              &#125;,</span><br><span class="line">                              &quot;init&quot;: &#123;</span><br><span class="line">                                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                                  &quot;name&quot;: &quot;answer&quot;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      ],</span><br><span class="line">                      &quot;kind&quot;: &quot;var&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">              ]</span><br><span class="line">          &#125;,</span><br><span class="line">          &quot;generator&quot;: false,</span><br><span class="line">          &quot;expression&quot;: false</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">          &quot;type&quot;: &quot;ExpressionStatement&quot;,//节点类型</span><br><span class="line">          &quot;expression&quot;: &#123;</span><br><span class="line">              &quot;type&quot;: &quot;CallExpression&quot;,</span><br><span class="line">              &quot;callee&quot;: &#123;</span><br><span class="line">                  &quot;type&quot;: &quot;Identifier&quot;,</span><br><span class="line">                  &quot;name&quot;: &quot;sau&quot;//调用的函数名</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;arguments&quot;: []</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;sourceType&quot;: &quot;script&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>tree结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line">  - node</span><br><span class="line">  - node</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p>tree根节点结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type:&apos;Program&apos;,</span><br><span class="line">  body:[</span><br><span class="line"></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>node 结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  type:&apos;xxx&apos;,</span><br><span class="line">  body:[</span><br><span class="line"></span><br><span class="line">  ],</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>除了变量node，其他的大概都有的两个属性 type body</p></li><li>除了type，body两个属性 每个节点上还包含了很多其他描述属性。比如：我们的函数声明node中包含一个id.name 就是我们的函数名， 而函数调用中有个expression.callee指向调用的函数名，我们只需要遍历整个树，查看定义的node 的id.name 在expression.callee中是否存在 就能知道我们的这个函数是否被调用过，如果没有调用过 我们就可以把这个函数定义的node删除掉！然后再把抽象语法树转换成js代码就ok了</li></ol><blockquote><p>上面的实现中，有三个比较重要的步骤</p><ol><li>js =&gt; ast</li><li>遍历ast 修改</li><li>ast =&gt; js</li></ol></blockquote><h2 id="如何把js解析成语法树"><a href="#如何把js解析成语法树" class="headerlink" title="如何把js解析成语法树"></a>如何把js解析成语法树</h2><p>这里，个人能力的缘故还不到去关注js＝&gt;ast转换的实现细节的时候，我们只要能实现就行，比较流行的有两个库：</p><ol><li><a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">esprima</a> 把js转换成ast</li><li><a href="https://github.com/facebookarchive/esprima" target="_blank" rel="noopener">esprima-fb 来自facebook,基于esprima</a> 兼容jsx js|jsx =&gt; ast</li></ol><p>demos: esprima-fb/</p><ol><li>js2ast.js =&gt; js解析成ast</li><li>js2ast-with-options.js 通过配置不同的解析参数 ［在线查看不同配置参数的解析结果］(<a href="http://esprima.org/demo/parse.html" target="_blank" rel="noopener">http://esprima.org/demo/parse.html</a>)</li></ol><h2 id="遍历ast树"><a href="#遍历ast树" class="headerlink" title="遍历ast树"></a>遍历ast树</h2><ol><li><a href="https://github.com/estools/estraverse" target="_blank" rel="noopener">estraverse</a></li><li><a href="https://github.com/jrajav/esprima-walk" target="_blank" rel="noopener">esprima-walk</a></li></ol><p>demos: esprima-walk</p><ol><li>walk.js</li></ol><h2 id="操作ast树"><a href="#操作ast树" class="headerlink" title="操作ast树"></a>操作ast树</h2><ol><li>生成的抽象语法树 是一个js对象 所以对树的操作 就和修改普通的js对象一样</li></ol><p>demos: escodegen-wallaby/</p><ol><li>gen.js 修改tree属性 重新生成js代码 保存</li></ol><h2 id="ast转换成js"><a href="#ast转换成js" class="headerlink" title="ast转换成js"></a>ast转换成js</h2><ol><li><a href="https://github.com/estools/escodegen" target="_blank" rel="noopener">escodegen</a></li><li><a href="https://github.com/wallabyjs/escodegen" target="_blank" rel="noopener">escodegen-wallaby</a> 兼容jsx 对应上面的esprima-fb</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阻止表单默认行为</title>
      <link href="/2017/11/09/js-form/"/>
      <url>/2017/11/09/js-form/</url>
      
        <content type="html"><![CDATA[<ol><li>使用添加属性的方式绑定事件 有下面的两种方法</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">form.onsubmit = function (e)&#123;</span><br><span class="line">   e.preventDefault();//method 1</span><br><span class="line">   return false;// 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>使用addEventListener添加的事件 只有一种方式</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">form.addEventListener(&apos;submit&apos;, function (e) &#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则实战</title>
      <link href="/2017/11/09/reg2/"/>
      <url>/2017/11/09/reg2/</url>
      
        <content type="html"><![CDATA[<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><blockquote><p>纸上得来终觉浅 绝知此事要躬行</p></blockquote><p><strong> 下面的实例都是简单的校验（前端一般够用）</strong></p><ol><li><p>手机号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 规则：</span><br><span class="line">/*纯数字 1开头 第二位34578 总共11位*/</span><br><span class="line">var telReg = /^1[34578]\d&#123;11&#125;/</span><br></pre></td></tr></table></figure></li><li><p>qq号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//规则：</span><br><span class="line">/*纯数字 非0数字开头 最少4位*/</span><br><span class="line">var qqReg = /^[1-9]\d&#123;4,&#125;/</span><br></pre></td></tr></table></figure></li><li><p>邮箱</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//规则：xxx@xx.xxx</span><br><span class="line">/*1. 肯定包含一个@ 2. 只能是字母数字，_- . */</span><br><span class="line">var qqReg = /^[\w\.-]+@[\w\.-]+\.[a-z\.]&#123;2,6&#125;/</span><br></pre></td></tr></table></figure></li><li><p>匹配url地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//规则：</span><br><span class="line">/*1. 以http:// https:// 开头 2. */</span><br><span class="line">var urlReg =/^https?:\/\/[\w-]+\.[a-z]&#123;2,6&#125;.*/</span><br></pre></td></tr></table></figure></li><li><p>身份证号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//规则：15或18位数字 或者 17位数字＋X|x</span><br><span class="line">var identifyReg = /(^\d&#123;15&#125;$)|(^\d&#123;17&#125;[\dXx]$)/</span><br></pre></td></tr></table></figure></li><li><p>一段html代码 替换style=”xxx”为空</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var styleReg = /\bstyle=&quot;[^&quot;]*&quot;/g</span><br></pre></td></tr></table></figure></li><li><p>把url解析成一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// http://www.qq.com/index.html?key1=1&amp;key2=2</span><br><span class="line">/**</span><br><span class="line">  &#123;</span><br><span class="line">    protocol: &quot;http&quot;,</span><br><span class="line">    hostname: &quot;www.qq.com&quot;,</span><br><span class="line">    pathname: &quot;index.html&quot;,</span><br><span class="line">    query: &quot;key1=1&amp;key2=2&quot;</span><br><span class="line">  &#125;</span><br><span class="line"> */</span><br><span class="line">var urlReg = /^(https?):\/\/([\w-\.]+\.[a-z]&#123;2,6&#125;)\/([\w-\.]*)\?([\w-=&amp;]*)/g</span><br><span class="line">urlReg.exec(&quot;http://www.qq.com/index.html?key1=1&amp;key2=2&quot;)</span><br><span class="line">//[&quot;http://www.qq.com/index.html?key1=1&amp;key2=2&quot;, &quot;http&quot;, &quot;www.qq.com&quot;, &quot;index.html&quot;, &quot;key1=1&amp;key2=2&quot;]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则基础</title>
      <link href="/2017/11/09/reg/"/>
      <url>/2017/11/09/reg/</url>
      
        <content type="html"><![CDATA[<h2 id="正则表达式是什么？"><a href="#正则表达式是什么？" class="headerlink" title="正则表达式是什么？"></a>正则表达式是什么？</h2><blockquote><p> regular expression 描述匹配否和一定规则的字符串</p><ol><li>是一种规则描述</li><li>用来匹配字符串</li></ol></blockquote><p>工具：</p><ol><li><a href="https://regexper.com" target="_blank" rel="noopener">https://regexper.com</a></li></ol><h2 id="正则基础"><a href="#正则基础" class="headerlink" title="正则基础"></a>正则基础</h2><ul><li>原意字符<br>就是本身的含义： a=&gt;a</li><li>元字符，在正则表达式中有特殊含义的非字母字符:<br> ? + *  $ ^ | \ . + () {} []</li></ul><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><table><thead><tr><th>书写格式</th><th>匹配含义</th></tr></thead><tbody><tr><td>.</td><td>任意字符</td></tr><tr><td>/d</td><td>数字，和[0-9]效果一样</td></tr><tr><td>/D</td><td>非数字，和[^0-9] 效果一样</td></tr><tr><td>/w</td><td>字母和下划线 [a-zA-Z_]</td></tr><tr><td>/W</td><td>非字母和下划线 [^a-zA-Z_]</td></tr><tr><td>/b</td><td>单词边界</td></tr><tr><td>/B</td><td>非单词边界</td></tr><tr><td>/s</td><td>空格 tab 等</td></tr><tr><td>^xx</td><td>以xx开头</td></tr><tr><td>xx$</td><td>以xx结束</td></tr><tr><td>-</td><td>从哪到哪: [a-z]</td></tr><tr><td>[]</td><td>或 [abc] ,a 或b或c</td></tr><tr><td>()</td><td>分组</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th>书写格式</th><th>匹配含义</th></tr></thead><tbody><tr><td>*</td><td>任意次</td></tr><tr><td>+</td><td>至少一次</td></tr><tr><td>?</td><td>一次或者0次</td></tr><tr><td>{n}</td><td>正好n次</td></tr><tr><td>{n,}</td><td>至少n次，注意逗号后面不能有空格</td></tr><tr><td>{0,n}</td><td>至多n次</td></tr><tr><td>{n,m}</td><td>至少n次， 至多m次</td></tr></tbody></table><h2 id="贪婪模式-和-非贪婪模式"><a href="#贪婪模式-和-非贪婪模式" class="headerlink" title="贪婪模式 和 非贪婪模式"></a>贪婪模式 和 非贪婪模式</h2><p>贪婪模式，尽可能多的匹配 ，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\d&#123;3,6&#125;/</span><br><span class="line">&quot;23344444&quot;.replace(reg, &apos;&apos;) // 44</span><br></pre></td></tr></table></figure></p><p>如果我只是想实现 在现3-6数字 把前三个数字替换成空呢<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var reg = /\d&#123;3,6&#125;?/</span><br><span class="line">&quot;23344444&quot;.replace(reg, &apos;&apos;) // 44444</span><br></pre></td></tr></table></figure></p><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>将几个字符作为单元进行匹配<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//匹配 连续出现3次ngnice的字符串</span><br><span class="line">var reg = /ngnice&#123;3&#125;/ //error</span><br><span class="line">匹配结果=&gt; ngniceee</span><br><span class="line">var reg = /(ngnice)&#123;3&#125;/ //right</span><br></pre></td></tr></table></figure></p><p>分组中的反向引用，即我们可以把分组捕获的值当作一个变量来引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//2015-05-11 =&gt; 11/05/2015</span><br><span class="line">var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="line">&quot;2015-05-11&quot;.replace(reg, &apos;$3/$2/$1&apos;)</span><br></pre></td></tr></table></figure><p>忽略分组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var reg = /(\d&#123;4&#125;)-(?:\d&#123;2&#125;)-(\d&#123;2&#125;)/</span><br><span class="line">&quot;2015-05-11&quot;.replace(reg, &apos;$3/$2/$1&apos;)</span><br><span class="line">$1 =&gt; 2015</span><br><span class="line">$2 =&gt; 11</span><br><span class="line">$3 =&gt; $3  //没有捕获就是字符串本身</span><br></pre></td></tr></table></figure></p><p>正则前瞻匹配 （这里的前 指的是xx的后面） 所以它的作用就是找到后面紧跟的是xxx的xxx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">现在我们有个需求，匹配下面字符串中的“的”，并且是后面有“中国”两个字。</span><br><span class="line">var str = &quot;美丽的华山，美丽的中国！&quot;;</span><br><span class="line">str.search(/的(?=中国)/)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 正则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js解析过程</title>
      <link href="/2017/11/09/javascript-context/"/>
      <url>/2017/11/09/javascript-context/</url>
      
        <content type="html"><![CDATA[<h2 id="js解析执行过程"><a href="#js解析执行过程" class="headerlink" title="js解析执行过程"></a>js解析执行过程</h2><p>分为两步：</p><ol><li><p>预解析 切换执行上下文 把［var声明的变量］和［function声明的函数］放到执行上下文(context)的变量对象(variables object)上，说白了就是创建存储空间。<br>如果是在c等静态类型语言中， 我们在使用一个变量或者是函数之前 必须先声明 才能使用， 然而在js中 我们却可以在声明之前使用，其实这就是预解析的作用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">alert(name) //undefined  不会报错</span><br><span class="line">var name = &apos;ngnice&apos;;</span><br><span class="line"></span><br><span class="line">say();//hello 不会报错</span><br><span class="line">function say()&#123;</span><br><span class="line">  console.log(&apos;hello&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行js代码<br>完成预解析之后， 才真正的开始执行代码， 所以上一步的操作 很像是把我们可能不规范的代码格式化成类似c（先声明，后使用）的规范的代码</p></li></ol><blockquote><p>这两个过程 在js加载完成之后的初始化执行，函数调用，eval执行都会发生</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;ngnice&apos;;</span><br><span class="line">function say()&#123;</span><br><span class="line">  var name = &apos;inner&apos;;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">say()</span><br></pre></td></tr></table></figure><ol><li><p>上面的代码执行的时候：先创建一个活动对象（预解析，规范化）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VO =&#123;</span><br><span class="line">  name:undefined,</span><br><span class="line">  say: function say()&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = &apos;ngnice&apos;//赋值</span><br><span class="line">say()//函数调用</span><br></pre></td></tr></table></figure></li><li><p>还记得吗 函数调用的时候也会进行上面的两个操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//预解析 声明变亮</span><br><span class="line">VO=&#123;</span><br><span class="line">  name: undefined</span><br><span class="line">&#125;</span><br><span class="line">//代码执行</span><br><span class="line">name = &apos;inner&apos;;//赋值</span><br><span class="line">console.log(name)//输出inner</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><ol><li><a href="http://www.cnblogs.com/yupeng/archive/2012/04/08/2437959.html" target="_blank" rel="noopener">http://www.cnblogs.com/yupeng/archive/2012/04/08/2437959.html</a></li></ol><p>实战：</p><ol><li>面试题1<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn(a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">  var a = 2;</span><br><span class="line">  function a() &#123;&#125;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(1)</span><br></pre></td></tr></table></figure></li></ol><p>执行fn时候：</p><ol><li>进入fn函数的执行上下文，</li><li><p>创建VO对象（函数中等同于AO）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">VO=&#123;</span><br><span class="line">  arguments:&#123;</span><br><span class="line">    0:function a()&#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(a) //function a()&#123;&#125;</span><br><span class="line">a = 2 //赋值</span><br><span class="line">console.log(a)  //a</span><br></pre></td></tr></table></figure></li></ol><p>结论：</p><blockquote><ol><li>参数赋值发生在预解析阶段，即：在预解析完成之后，参数的值就是参数的值 如果函数内部有和参数同名的函数声明 就会对参数的值进行修改；实际的效果就是同名的函数声明会覆盖掉实参的值（函数声明优先规则）</li><li>函数内部和参数同名的变量 是参数的不同引用地址</li><li>如果内部有和参数同名的变量声明 则不会对VO的同名属性造成影响</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>执行上下文</title>
      <link href="/2017/11/09/javascript-exc/"/>
      <url>/2017/11/09/javascript-exc/</url>
      
        <content type="html"><![CDATA[<h2 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h2><blockquote><p>每当控制器进入ECMAscript可执行代码的时候，控制器就进入了一个可执行上下文。可执行上下文（简称EC）是一个抽象的概念，在ECMA262中用他来区分不同类型的可执行代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我们定义一个可执行上下文的堆栈用数组表示</span><br><span class="line">ECStack = []</span><br></pre></td></tr></table></figure></p></blockquote><p>可执行代码的类型：</p><ol><li><p>js加载完成之后的初始化（就是我们平时放到最外层，window下执行的代码）会创建一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>函数执行 会把当前函数的执行上下文压入栈中，执行完成之后 再出栈销毁</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//执行 push</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext,</span><br><span class="line">  functionContext</span><br><span class="line">];</span><br><span class="line">//执行后 pop</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext,</span><br><span class="line">  functionContext</span><br><span class="line">];</span><br></pre></td></tr></table></figure></li><li><p>eval 也会形成执行上下文</p></li></ol><p>实例分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var name = &apos;ngnice&apos;</span><br><span class="line">function outer()&#123;</span><br><span class="line">  function inner()&#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer()</span><br></pre></td></tr></table></figure><p>上面的代码执行的过程中的上下文变化：</p><ol><li><p>脚本加载完成初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>执行outer函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//push outerContext</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext,</span><br><span class="line">  outerContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>执行inner函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//push innerContext</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">  outerContext,</span><br><span class="line">  innerContext,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>执行完毕inner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//pop innerContext</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext,</span><br><span class="line">  outerContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>执行完毕outer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//pop outerContext</span><br><span class="line">ECStack = [</span><br><span class="line">  globalContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ol><p>参考：</p><ol><li><a href="http://www.cnblogs.com/yupeng/archive/2012/04/07/2436616.html" target="_blank" rel="noopener">http://www.cnblogs.com/yupeng/archive/2012/04/07/2436616.html</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端乱码问题</title>
      <link href="/2017/11/09/bianmawenti/"/>
      <url>/2017/11/09/bianmawenti/</url>
      
        <content type="html"><![CDATA[<h3 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h3><p>乱码问题 其实就是“你说的我不懂！”</p><blockquote><p>要说清楚乱码问题 首先，需要明白http协议<br>http 协议简单理解就是客户端和服务端之间的一个约定。</p></blockquote><p>其中的一个约定是关于传送内容的类型的： Content-Type<br>服务器在返回响应的时候 会指定文件的类型：Content-Type</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//图片类型</span><br><span class="line">Content-Type:image/png</span><br><span class="line">//js文件</span><br><span class="line">Content-Type:application/javascript;charset=UTF-8</span><br><span class="line">//这个类型 兼容老得掉牙的浏览器</span><br><span class="line">Content-Type:application/x-javascript</span><br></pre></td></tr></table></figure><p>Content-Type字段指定文件的类型同时还能指定浏览器要使用什么字符集进行解码</p><p>同时文件在生成的时候 我们也指定了文件的编码字符集。</p><p>所以会出现下面的两种情况：</p><ol><li>服务器端指定的解码字符集和文件本身的编码字符集相同 ＝》结果：正确解析文件（没有乱码）</li><li>服务器端指定的解码字符集和文件本身的编码字符集不同<br>＊ 如果解码字符集能够解析编码的字符集（类似英国人能够翻译美国人的话）文件正确解析（没有乱码）<br>＊ 指定的解码字符集不能解析编码字符集（你丫的，我听不懂！） 于是，出现了乱码问题</li></ol><blockquote><p>好了，问题有了，怎么解决？？？</p></blockquote><ol><li>指定正确的解码字符集</li><li>修改文件成服务器指定的字符集</li><li>文件内容修改成能够被解码（不改变编码字符集）啊哈 这个说的有点抽象 来个栗子：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//js文件我们使用汉字 编码格式 utf-8</span><br><span class="line">console.log(&apos;中国&apos;)</span><br><span class="line">//解码字符集指定为gb2312 －》出现乱码</span><br><span class="line"></span><br><span class="line">//修改文件内容 汉字＝》unicode</span><br><span class="line">console.log(&apos;\u4e2d\u56fd&apos;) //我能行 我很行！</span><br></pre></td></tr></table></figure><p>下一节，去学习怎么使用js来把汉字转换成unicode字符</p><blockquote><p>如何使用js来把汉字转成unicode编码</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//转换成unicode</span><br><span class="line">escape(str).toLocaleLowerCase().replace(/%u/gi,&apos;\\u&apos;);</span><br><span class="line">//转换成gb2312</span><br><span class="line">unescape(str.replace(/\\u/gi, &apos;%u&apos;));</span><br></pre></td></tr></table></figure><p>这里使用了两个函数 escape 和 unescape</p><p>1.<br>escape 将字符转换成16进制字符串<br>该方法不会对 ASCII 字母和数字进行编码，也不会对下面这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( )</p><p>后面的正则替换部分，后续！！<br>后面的正则替换部分，后续！！</p><h3 id="escape-encodeURI-encodeURIComponent-的区别"><a href="#escape-encodeURI-encodeURIComponent-的区别" class="headerlink" title="escape encodeURI encodeURIComponent 的区别"></a>escape encodeURI encodeURIComponent 的区别</h3><ol><li><p>escape</p><blockquote><ul><li>不会对ASCII 字母和数字进行编码；</li><li>不会对ASCII - _ . ! ~ * ‘ ( )进行编码</li></ul></blockquote></li><li><p>encodeURI</p><blockquote><ul><li>不会对ASCII 字母和数字进行编码；</li><li>不会对ASCII - _ . ! ~ * ‘ ( )进行编码</li><li>不会对 ;/?:@&amp;=+$,# 进行编码</li></ul></blockquote></li><li><p>encodeURIComponent</p><blockquote><ul><li>不会对ASCII 字母和数字进行编码；</li><li>不会对ASCII - _ . ! ~ * ‘ ( )进行编码</li><li><hr></li><li>但是会对 ;/?:@&amp;=+$,# 进行编码</li><li>但是会对 ;/?:@&amp;=+$,# 进行编码</li><li>但是会对 ;/?:@&amp;=+$,# 进行编码</li></ul></blockquote></li></ol><p>escape 的功能和encodeURIComponent 比较相似，因为encodeURIComponent就是对uri的参数部分进行处理</p><blockquote><p>适合的场景：<br>我们在url中经常需要加上某个url作为参数 ，我们在解析这个url的时候会比较麻烦，因为在参数中同时包含了一个url；<br>这个时候我们就可以使用 encodeURIComponent 对传入的url参数进行编码</p></blockquote><p>总结：</p><ol><li>escape就是对字符串进行编码，如果涉及到url就不要使用这个，</li><li>encodeURI 适合对整个url进行编码</li><li>encodeURIComponent 适合对作为参数的url进行编码</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 乱码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2017/11/09/webpack/"/>
      <url>/2017/11/09/webpack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下面的是自己学习webpack的一些总结：</p></blockquote><ol><li><a href="https://github.com/webaifei/webpack-examples" target="_blank" rel="noopener">自我学习笔记总结</a></li><li>参考地址：<ul><li><a href="webpack.github.io">官网</a> 虽然官网确实有些地方写的不是很清楚 但是应该是比较权威的</li><li><a href="https://github.com/SamHwang1990/webpack-demos" target="_blank" rel="noopener">阮一峰老师的demo</a></li></ul></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node实现命令行工具</title>
      <link href="/2017/11/09/node-cmd/"/>
      <url>/2017/11/09/node-cmd/</url>
      
        <content type="html"><![CDATA[<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>linux下的常见目录和作用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/                                             --------根目录</span><br><span class="line">├── Applications                              --------mac下的程序存放目录</span><br><span class="line">├── Library</span><br><span class="line">├── Network</span><br><span class="line">├── System</span><br><span class="line">├── Users</span><br><span class="line">├── Volumes</span><br><span class="line">├── bin                                       --------系统命令目录 （任何用户都能执行的命令）</span><br><span class="line">├── com.apple.mDNSResponder.plist.sonicwall.bk</span><br><span class="line">├── cores</span><br><span class="line">├── dev                                       --------硬件文件目录</span><br><span class="line">├── etc -&gt; private/etc                        --------配置文件目录</span><br><span class="line">├── export</span><br><span class="line">├── home                                      --------普通用户目录</span><br><span class="line">├── installer.failurerequests</span><br><span class="line">├── net</span><br><span class="line">├── opt</span><br><span class="line">├── private</span><br><span class="line">├── sbin                                      --------系统命令目录 （只有root用户才能执行的命令）</span><br><span class="line">├── tmp -&gt; private/tmp</span><br><span class="line">├── usr</span><br><span class="line">  ├── bin                                     --------系统命令目录 （任何用户都能执行的命令）</span><br><span class="line">  ├── sbin                                    --------系统命令目录 （只有root用户才能执行的命令）</span><br><span class="line">└── var -&gt; private/var</span><br></pre></td></tr></table></figure></p><p>需要注意的文件目录：</p><ol><li>bin 和 sbin 都是存放系统命令的地方 ；区别是sbin目录中的命令只有root用户才能执行</li><li>etc目录 是存放系统配置文件的目录， 比如hosts文件就在其中</li></ol><p>linux 连接命令 link</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ln -s 软连接 (快捷方式)</span><br><span class="line">1. 拥有自己的i节点和block数据块（存储着数据 只不过存储的数据是原文件的i节点的指针）</span><br><span class="line">2. 删除了原文件的话 软连接是不能正常使用的 ；删除软连接的话 是不影响硬链接的使用的</span><br><span class="line">3. 创建软连接的话 源文件 需要指定绝对路径（如果不指定就会在当前目录下找）</span><br><span class="line"></span><br><span class="line">ln 硬链接 相同的i节点 相同的文件块 （可以认为是不同的指针指向同一个文件）</span><br><span class="line">1. 不能跨分区</span><br><span class="line">2. 不能针对目录</span><br></pre></td></tr></table></figure><p>macOs 中添加环境变量的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 我们如果想在任何目录下使用我们的命令的话 就需要把我们的命令文件所在的绝对路径添加到环境变量中。</span><br><span class="line">2. 和windows系统比较像，macOs中也分为系统环境变量和用户变量</span><br><span class="line">3.  /etc/profile (公有的 不论哪个用户登录的 都生效)</span><br><span class="line">    /etc/bashrc (公有的 不论哪个用户登录的 都生效)</span><br><span class="line">    ~/.bash_profile(个人用户中的配置 建议使用)</span><br></pre></td></tr></table></figure></p><p>如何添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. echo $PATH //查看当前的系统变量</span><br><span class="line">2. 打开 ~/.bash_profile 添加如下：</span><br><span class="line"># 定义一个HELLO变量</span><br><span class="line">export HELLO=/Users/ngnice/projects/fe-note/node-commond-line</span><br><span class="line"># 添加到$PATH中</span><br><span class="line">export PATH=$HELLO:$PATH</span><br><span class="line">3. 保存，退出。</span><br><span class="line">4. source .bash_profile (立即生效当前的修改， 默认是每次重启登录的时候读取)</span><br></pre></td></tr></table></figure></p><h3 id="文件的权限"><a href="#文件的权限" class="headerlink" title="文件的权限"></a>文件的权限</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 执行ls -lsh</span><br><span class="line">8 -rw-r--r--  1 ngnice  staff   500B  1 13 11:06 PATH</span><br><span class="line">0 drwxr-xr-x  4 ngnice  staff   136B  1 13 10:34 china</span><br><span class="line">8 -rw-r--r--  1 ngnice  staff    39B 11  5 20:13 file2.js</span><br><span class="line">0 drwxr-xr-x  4 ngnice  staff   136B  1 26  2016 japan</span><br><span class="line">0 drwxr-xr-x  5 ngnice  staff   170B  1 25  2016 nice</span><br><span class="line">8 lrwxr-xr-x  1 root    staff     6B  1 13 11:47 soft-china -&gt; china/</span><br><span class="line">0 drwxr-xr-x  7 ngnice  staff   238B  5 27  2016 src</span><br></pre></td></tr></table></figure><p>linux中的文件类型和权限分类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--</span><br><span class="line">上面的第一个“-”代表的是文件类型</span><br><span class="line">常见的 ：</span><br><span class="line">-  -》普通文件</span><br><span class="line">d  -》目录文件</span><br><span class="line">l  -》软连接文件</span><br><span class="line">后面的9位 每三位一组 分别代表所有者，所有组，其他人权限</span><br><span class="line">r 代表 read （可读权限）</span><br><span class="line">w 代表 write （可写权限）</span><br><span class="line">x 代表 execute （可执行权限）</span><br></pre></td></tr></table></figure></p><p>linux 中如何修改文件（linux中一切皆文件）的权限</p><ol><li>chmod u+x xxx//给xxx所有者添加可执行权限（增加）</li><li>chmod g-r xxx //给xxx的所有组删除可读权限（删除）</li><li>chmod o=rwx xxx//给xxx的其他人赋予所有权限（重新赋值）</li><li>chmod 755 xxx//我擦嘞，这个是啥？</li></ol><blockquote><p>linux 中不同的权限可以使用不同的数字代表;r = 4 ,w=2,x=1;所以 chmod 755 xxx 的意思就是给xxx的所有者全部权限，给所有组读和执行权限，其他人也是读和执行权限</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm一些记录</title>
      <link href="/2017/11/09/npm/"/>
      <url>/2017/11/09/npm/</url>
      
        <content type="html"><![CDATA[<ul><li><p>npm设置淘宝源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.在项目根目录下新建 .npmrc</span><br><span class="line">写入：</span><br><span class="line">registry = https://registry.npm.taobao.org</span><br><span class="line">2. npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li><li><p>npm发布包 报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">no_perms Private mode enable, only admin can publish this module: xxx</span><br><span class="line"></span><br><span class="line">修改npm源为 https://registry.npmjs.org 就行了</span><br><span class="line">npm config set registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些不常用用的css写法</title>
      <link href="/2017/11/09/css/"/>
      <url>/2017/11/09/css/</url>
      
        <content type="html"><![CDATA[<h4 id="font"><a href="#font" class="headerlink" title="font"></a>font</h4><p>按照如下的顺序书写</p><ol><li>font-style</li><li>font-variant</li><li>font-weight</li><li>font-size/line-height</li><li>font-family</li></ol><ul><li>其中 属性4、5必须同时书写，其他的属性可以缺少（使用默认值） *<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.title&#123;</span><br><span class="line">    font: 18px/26px Arial;</span><br><span class="line">&#125;</span><br><span class="line">.titile-small&#123;</span><br><span class="line">  font: 600 14px/26px Arial;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="多行显示省略号-会使整个高度减少"><a href="#多行显示省略号-会使整个高度减少" class="headerlink" title="多行显示省略号 会使整个高度减少"></a>多行显示省略号 会使整个高度减少</h4><h4 id="line-height-文字居中-下面会多出一个px"><a href="#line-height-文字居中-下面会多出一个px" class="headerlink" title="line-height 文字居中 下面会多出一个px"></a>line-height 文字居中 下面会多出一个px</h4>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml实体</title>
      <link href="/2017/11/09/xml/"/>
      <url>/2017/11/09/xml/</url>
      
        <content type="html"><![CDATA[<blockquote><p>xml中有些具有特定含义的字符，比如 &lt; 标记一个xml标签的开始。如果我们想要展示的是纯文本，而不想让解析器解析成标签的开始标记的话，我们就需要使用它的实体引用，否则会出现语法错误等情况。</p></blockquote><h4 id="xml中的实体引用"><a href="#xml中的实体引用" class="headerlink" title="xml中的实体引用"></a>xml中的实体引用</h4><p><img src="http://pic002.cnblogs.com/images/2012/424368/2012112622045516.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> 实体 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器解析过程</title>
      <link href="/2017/11/09/browser-md/"/>
      <url>/2017/11/09/browser-md/</url>
      
        <content type="html"><![CDATA[<h3 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h3><p>浏览器就是请求资源 展示到用户面前</p><ol><li>用户界面 UI</li><li>呈现引擎 负责显示请求的内容</li><li>网络 用于网络调用</li><li>用户界面后端</li><li>JavaScript 解释器</li><li>数据存储</li></ol><h3 id="页面解析过程"><a href="#页面解析过程" class="headerlink" title="页面解析过程"></a>页面解析过程</h3><ol><li>浏览器地址栏输入url </li><li>DNS解析(DNS解析会查找浏览器的缓存，本地缓存等等)</li><li>浏览器使用网络模块发起请求</li><li>server返回html，下载完成</li><li>浏览器开始Parse HTML（解析一部分，就会渲染，并不是全部解析完成之后再去渲染）</li><li>浏览器发现一个加载css的外链， 发起一个请求加载这个样式表文件，期间（下载css文件和解析css文件期间）， 不阻塞Parse HTML（可以使用添加async的js脚本来验证）,但是因为css tree 没有构建完成，所以无法和DOM tree 一起构成render tree，后面的 layout, paint 也无法进行，所以文档后面内容无法展现到浏览器上</li><li>发现一个外链js文件，发起一个请求，去请求js,期间（下载js解析执行js脚本）会阻塞document的解析，所以会导致阻塞后面dom tree和后面的css tree的构建，最终导致阻塞 render tree的形成，所以浏览器上看不到显示（注意：这个时候现代浏览器都会启动另外的线程去解析剩余的document，去加载后面的外部资源，但是不会影响dom tree）</li></ol><table><thead><tr><th>文件类型</th><th>是否阻塞后续DOM tree解析</th><th>是否阻塞后续 css tree</th><th>是否阻塞后续 render tree</th><th>是否影响最终展现屏幕上</th><th>备注</th></tr></thead><tbody><tr><td>css样式</td><td>👍</td><td>👎</td><td>👎</td><td>👎</td><td>阻塞js的执行</td></tr><tr><td>js脚本</td><td>👎</td><td>👎</td><td>👎</td><td>👎</td><td>js的下载和执行会阻塞dom 解析，自然会阻塞css tree的解析， 但是现代浏览器都会启动另外的线程去解析剩下的dom，但是只会下载需要的资源</td></tr></tbody></table><h4 id="验证demo地址"><a href="#验证demo地址" class="headerlink" title="验证demo地址"></a><a href="https://github.com/webaifei/js-topics/tree/master/browser-parsing-process" target="_blank" rel="noopener">验证demo地址</a></h4><h3 id="js脚本异步加载"><a href="#js脚本异步加载" class="headerlink" title="js脚本异步加载"></a>js脚本异步加载</h3><ol><li>使用defer属性 作用是：异步的加载js脚本<ol><li>不会阻塞页面的渲染 会异步的加载 等到dom构建完成之后 再去执行脚本（异步的下载 dom之后执行）</li></ol></li><li>使用async属性（html5新增）<ol><li>不会阻塞页面的渲染 并且下载完成之后异步的解析执行（异步下载 异步执行）</li></ol></li></ol><p>同时拥有async 和 defer的时候 , async优先级高</p><h3 id="css的解析"><a href="#css的解析" class="headerlink" title="css的解析"></a>css的解析</h3><blockquote><p>css解析规则 是从右向左</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div p em&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>另一方面，样式表的处理有这不同的模型。理论上来说，由于样式表不会改变dom结构，所以没有必要等待他们而停止文档解析。但是有一个问题：在文档解析阶段，脚本访问了样式信息，如果样式表没有下载完成，解析完毕，脚本将得到错误的答案，这样会引起很多问题。貌似是一个极端情况，却很常见。</p></blockquote><ol><li>firfox将会阻止所有的脚本，当还有没下载和解析的脚本时。</li><li>WebKit仅在用户尝试访问未加载样式表可能影响的某些样式属性时阻止脚本。</li></ol><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.http协议的网页加载https的外部资源（非跨域情况）都能无伤加载<br>2.https协议的网页不能加载http的外部资源</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器运行机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>history对比hash 【前端路由】</title>
      <link href="/2017/11/09/history-md/"/>
      <url>/2017/11/09/history-md/</url>
      
        <content type="html"><![CDATA[<p>pushState replaceState 对比hash切换</p><table><thead><tr><th>option</th><th>h5 history</th><th>hash</th></tr></thead><tbody><tr><td>只要不去点击刷新或者重新载入页面不刷新页面</td><td>✅</td><td>✅</td></tr><tr><td>都能够产生history历史记录</td><td>✅</td><td>✅</td></tr><tr><td>能够分享出去连接 传播性</td><td>✅</td><td>✅</td></tr><tr><td>是否能被爬虫</td><td>✅（需要服务端对对应的路径进行相应）</td><td>❌</td></tr><tr><td>服务端能够区别不同的请求路径</td><td>✅</td><td>❌</td></tr><tr><td>页面刷新的时候 服务端能够匹配不同的路径 返回首屏数据</td><td>✅</td><td>❌</td></tr><tr><td>页面刷新的时候 不需要服务端配置</td><td>❌</td><td>✅</td></tr><tr><td>触发window的popstate事件</td><td>❌不能 通过js调用history.back() forward才触发</td><td>✅</td></tr><tr><td>hashchange事件</td><td>❌</td><td>✅</td></tr><tr><td>是否能够操作history replace</td><td>✅</td><td>❌</td></tr></tbody></table><p>总结下：</p><blockquote><p>history api 对搜索引擎更加友好； 操作history有更大的权限； 我们能够选择不保留某个历史记录（通过replaceState） 缺点是需要服务端的配合；<br><br><br>hash更加的简单 前端能够通过hashchange 来判断不同的路由 进行不同的业务展示</p></blockquote><p>注意点： window.onpopstate 事件的触发</p><ol><li>在通过history.back history.forward 等能触发</li><li>在hash切换的时候也能触发</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>xml获取html, js ,css</title>
      <link href="/2017/11/09/jiqiao/"/>
      <url>/2017/11/09/jiqiao/</url>
      
        <content type="html"><![CDATA[<p>问题源于一个面试题：</p><blockquote><p>通过xhr获取一html片段，其中包含html，css，js ，请问三种是否都能正常的解析执行？</p></blockquote><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">  xhr.open(&apos;get&apos;, &apos;./hasjsHtml.html&apos;, true);</span><br><span class="line">  xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.status == 200 &amp;&amp; xhr.readyState ==4)&#123;</span><br><span class="line">      console.log(xhr.responseText)</span><br><span class="line">      document.getElementById(&apos;test&apos;).innerHTML = xhr.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(null)</span><br><span class="line"></span><br><span class="line">//请求的html片段</span><br><span class="line">&lt;style&gt;</span><br><span class="line"></span><br><span class="line">#sdf&#123;</span><br><span class="line">  width: 100px;</span><br><span class="line">  height: 100px;</span><br><span class="line">  border: 1px solid #ccc;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div id=&quot;sdf&quot;&gt;</span><br><span class="line">  nice</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  alert(1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>结论：</p><ol><li>html，css样式都能够正常的解析和执行</li><li>js不能被执行</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>居中布局</title>
      <link href="/2017/11/09/html2/"/>
      <url>/2017/11/09/html2/</url>
      
        <content type="html"><![CDATA[<h2 id="居中布局"><a href="#居中布局" class="headerlink" title="居中布局"></a>居中布局</h2><blockquote><p>不论是面试还是工作中 我们经常遇到的问题就是居中（水平 垂直居中）</p></blockquote><h3 id="外部容器固定高度-需要居中的元素也固定高度"><a href="#外部容器固定高度-需要居中的元素也固定高度" class="headerlink" title="外部容器固定高度 需要居中的元素也固定高度"></a>外部容器固定高度 需要居中的元素也固定高度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为都是固定值 所以能够通过设置固定值来定位， 不论是通过margin还是position等</span><br></pre></td></tr></table></figure><h3 id="外部容器高度不固定-内部元素的高度固定"><a href="#外部容器高度不固定-内部元素的高度固定" class="headerlink" title="外部容器高度不固定 内部元素的高度固定"></a>外部容器高度不固定 内部元素的高度固定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*(无兼容问题)*/</span><br><span class="line">.center&#123;</span><br><span class="line">  width: 200px;</span><br><span class="line">  height: 220px;</span><br><span class="line">  background: #acb;</span><br><span class="line">  position: relative;</span><br><span class="line">  top: 50%;//把元素的左上角放到中心点</span><br><span class="line">  margin:0 auto;//水平居中</span><br><span class="line">  margin-top: -110px;//向上移动容器自身的一半</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外部容器高度固定-内部容器高度不固定"><a href="#外部容器高度固定-内部容器高度不固定" class="headerlink" title="外部容器高度固定 内部容器高度不固定"></a>外部容器高度固定 内部容器高度不固定</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*(兼容问题) IE67不支持display:table-cell;*/</span><br><span class="line">.wraper&#123;</span><br><span class="line">  display:table;</span><br><span class="line">  /*需要设置宽高*/</span><br><span class="line">  width:xxx;</span><br><span class="line">  height:xxx;</span><br><span class="line">&#125;</span><br><span class="line">.cell&#123;</span><br><span class="line">  display: table-cell;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*使用css3 */</span><br><span class="line">.center4&#123;</span><br><span class="line">  width: 50%;</span><br><span class="line">  position: relative;</span><br><span class="line">  /*拉倒中心*/</span><br><span class="line">  left: 50%;</span><br><span class="line">  top: 50%;</span><br><span class="line">  /*移动本身宽高的负1/2*/</span><br><span class="line">  transform: translate3d(-50%, -50%, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用vertical-align-middle来实现图文垂直居中（类似flex的效果）"><a href="#使用vertical-align-middle来实现图文垂直居中（类似flex的效果）" class="headerlink" title="使用vertical-align middle来实现图文垂直居中（类似flex的效果）"></a>使用vertical-align middle来实现图文垂直居中（类似flex的效果）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.list-item&#123;</span><br><span class="line">  padding: 10px;</span><br><span class="line">  /*如果设置了固定的高度  需要设置line-height来让vertical-align起作用 相应的内部元素都需要重新设置line-height*/</span><br><span class="line">&#125;</span><br><span class="line">.img&#123;</span><br><span class="line">  vertical-align:middle;</span><br><span class="line">&#125;</span><br><span class="line">.desc&#123;</span><br><span class="line">  display:inline-block;</span><br><span class="line">  vertical-align: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="强大的flex布局"><a href="#强大的flex布局" class="headerlink" title="强大的flex布局"></a>强大的flex布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.flex&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  display: -webkit-flex;</span><br><span class="line">  display: flex-box;</span><br><span class="line"></span><br><span class="line">  justify-content: center;//水平居中</span><br><span class="line">  -webkit-box-align: center;</span><br><span class="line">      -ms-flex-align: center;</span><br><span class="line">          align-items: center;</span><br><span class="line">&#125;</span><br><span class="line">.flex-item&#123;</span><br><span class="line">  flex: 1;</span><br><span class="line">  -webkit-box-flex: 1;</span><br><span class="line">  display: block;//兼容uc的bug</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="行内元素、块级元素、行内块级元素"><a href="#行内元素、块级元素、行内块级元素" class="headerlink" title="行内元素、块级元素、行内块级元素"></a>行内元素、块级元素、行内块级元素</h3><table><thead><tr><th>类型</th><th>设置宽高是否有效</th><th>margin</th><th>padding</th></tr></thead><tbody><tr><td>行内元素</td><td>无效</td><td>上下无效，左右有效</td><td>有效</td></tr><tr><td>行内块级元素</td><td>有效</td><td>都有效</td><td>有效</td></tr><tr><td>行内块级元素</td><td>有效</td><td>都有效</td><td>有效</td></tr></tbody></table><p>参考<a href="http://jsrun.net/itZKp" target="_blank" rel="noopener">例子</a></p><h3 id="em-rem"><a href="#em-rem" class="headerlink" title="em rem"></a>em rem</h3><ol><li>em相对单位， 相对于最近设置的font-size的值</li><li>rem相对于html上的font-size的值</li></ol><h3 id="css3-开启硬件加速"><a href="#css3-开启硬件加速" class="headerlink" title="css3 开启硬件加速"></a>css3 开启硬件加速</h3><p>使用 translate3d rotate3d rotate3d等属性可以开启GPU 硬件加速</p><p><a href="http://blog.teamtreehouse.com/increase-your-sites-performance-with-hardware-accelerated-css" target="_blank" rel="noopener">参考地址</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些知识点</title>
      <link href="/2017/11/09/html/"/>
      <url>/2017/11/09/html/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>总结了一些有用的面试知识点，没有什么规律</p><ol><li><p>解决chrome不允许设置&lt;12px的字体问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//网上有好多这样的说法 然后我傻傻的去试了下 ： 我擦 骗我！</span><br><span class="line">// 继续百度 发现这个是在低版本的chrome（27）中可以使用 高版本已经禁用了</span><br><span class="line">html&#123;</span><br><span class="line">  -webkit-text-size-ajust:none;</span><br><span class="line">&#125;</span><br><span class="line">// css3 使用transform:scale()来实现</span><br><span class="line"></span><br><span class="line">.f10&#123;</span><br><span class="line">  font-size: 12px;</span><br><span class="line">  transform:scale(0.875);</span><br><span class="line">  transform-origin: left bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>网页布局之圣杯布局和双飞翼布局</p><blockquote><p>首先明白一点，这两种布局概念的提出都是为了解决网页左中右三栏布局的问题</p><ol><li>要求左右两栏固定宽度， 中间的内容宽度自适应</li><li>一般中间的内容很重要，需要优先解析展示</li></ol></blockquote><p>正常情况下，我们直接使用浮动就能够解决问题1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*css*/</span><br><span class="line">.container&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">  float:left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background:#f00;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">  float: right;</span><br><span class="line">  width: 150px;</span><br><span class="line">  background:#ff0;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">  padding: 0 150px 0 200px;</span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*html 结构*/</span><br><span class="line">.container&gt;.left+.right+.center</span><br></pre></td></tr></table></figure><h3 id="上面的布局结构-能够解决问题1，-但是问题2却无法解决，改进方案-圣杯布局-："><a href="#上面的布局结构-能够解决问题1，-但是问题2却无法解决，改进方案-圣杯布局-：" class="headerlink" title="上面的布局结构 能够解决问题1， 但是问题2却无法解决，改进方案(圣杯布局)："></a>上面的布局结构 能够解决问题1， 但是问题2却无法解决，改进方案(圣杯布局)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/*html structure*/</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;center&quot;&gt;中间内容&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;导航&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;右侧内容&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*css*/</span><br><span class="line">div&#123;</span><br><span class="line">  min-height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line">  padding: 0 150px 0 200px;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">  float:left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background:#f00;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">  z-index: 10;</span><br><span class="line">  position: relative;</span><br><span class="line">  left: -200px;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 150px;</span><br><span class="line">  background:#ff0;</span><br><span class="line">  margin-left: -150px;</span><br><span class="line">  position: relative;</span><br><span class="line">  right: -150px;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  float: left;</span><br><span class="line"></span><br><span class="line">  background: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的主要原理：</p><ol><li>通过margin-left 负值把left 和 right 部分拉到和center同列中 给外层的container设置padding 通过定位把left 和 right 定位到正确的位置上。</li></ol><p>ps： 太诡异了</p><h3 id="国内淘宝ued团队的双飞翼布局"><a href="#国内淘宝ued团队的双飞翼布局" class="headerlink" title="国内淘宝ued团队的双飞翼布局"></a>国内淘宝ued团队的双飞翼布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*html structure*/</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;center&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;inner&quot;&gt;我是中间&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">/*css*/</span><br><span class="line">div&#123;</span><br><span class="line">  min-height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.container&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">  float:left;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background:#f00;</span><br><span class="line">  margin-left: -100%;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">  float: left;</span><br><span class="line">  width: 150px;</span><br><span class="line">  background:#ff0;</span><br><span class="line">  margin-left: -150px;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  float: left;</span><br><span class="line">  background: blue;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.inner&#123;</span><br><span class="line">    padding: 0 150px 0 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>主要解决思路 把中间的部分放到一个单独的div中 通过这个容器来设置padding</p><ol><li>免去了设置定位</li><li>结构样式控制更加合理</li></ol></blockquote></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络层概述</title>
      <link href="/2017/11/09/network/"/>
      <url>/2017/11/09/network/</url>
      
        <content type="html"><![CDATA[<ol><li>网络层应该向运输层提供怎样的服务？<br>无连接的，可靠交付由端系统负责的数据报服务。</li></ol><p>因为电信网的成功使用（电话服务），有人建议互联网也采用这种方式来实现。<br>具体实现：<br>需要通信的两端 先建立一个虚拟链接（占用一条通路），然后发送分组，通信结束后释放链接。</p><blockquote><p>特点：</p><ol><li>需要建立链接</li><li>不需要填写完整的目的主机地址，只需要填写虚电路的编号，节省了分组的开销。</li><li>分组无差错按序到达终点，不会存在丢失，重复的情况。</li></ol></blockquote><p>问题：</p><ol><li>使用虚电路，利用率较低，会有很多的空闲时间被占用</li><li>容错，健壮性不好，如果建立的虚拟电路挂掉了，服务就无法送达。</li><li>单条通路容易出现阻塞。</li><li>价格昂贵（比如电信网程控交换机 复杂昂贵）</li></ol><p>所有，人们提出另外的一种思路：网络层向上（运输层）提供简单灵活，无连接，尽最大努力交付的数据报服务。<br>有一下的特点：</p><ol><li>不需要建立连接</li><li>分组独立发送，不进行编号，不保证服务质量。</li><li>路由器比较简单 造价低廉（和电信网的交换机相比）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript 位运算</title>
      <link href="/2017/11/09/js-wei/"/>
      <url>/2017/11/09/js-wei/</url>
      
        <content type="html"><![CDATA[<h3 id="amp-按位与"><a href="#amp-按位与" class="headerlink" title="&amp; 按位与"></a>&amp; 按位与</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.判断奇偶数,原理就是 奇数二进制位最后一位一定为1 和 1做&amp; 运算一定是1 ，而偶数一定是0</span><br><span class="line">n&amp;1</span><br><span class="line">2. | 或运算向下取正</span><br><span class="line">n|0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell基础</title>
      <link href="/2017/11/09/shell/"/>
      <url>/2017/11/09/shell/</url>
      
        <content type="html"><![CDATA[<h3 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h3><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;ngnice&quot;</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure><blockquote><p>TIPS</p><ol><li>直接变量 不需要其他的标识符标识是变量名称， 例如js中通过 var来定义变量</li><li>引用变量通过 $your_varaiable</li><li>赋值运算符前后不能有空格</li></ol></blockquote><h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//比较特殊的是数值运算</span><br><span class="line">aa=1</span><br><span class="line">bb=2</span><br><span class="line">echo $aa+$bb//1+2 原封不动的输出 没有进行数值的加法运算</span><br><span class="line"></span><br><span class="line">//使用expr  但是需要注意+前后必须要有空格</span><br><span class="line">echo $(expr $aa + $bb) //3</span><br><span class="line">//使用 $(())来实现  I like it~</span><br><span class="line">echo $(($aa+$bb))</span><br><span class="line">//使用$[]  同样不错</span><br><span class="line">echo $[$aa+$bb]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx基础</title>
      <link href="/2017/11/09/nginx/"/>
      <url>/2017/11/09/nginx/</url>
      
        <content type="html"><![CDATA[<h2 id="location匹配"><a href="#location匹配" class="headerlink" title="location匹配"></a>location匹配</h2><blockquote><p>按照匹配优先级顺序</p><ol><li>=  精准匹配 完全匹配  比较适合匹配某个特定的路径<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//只能匹配/index 其他的都不行，例如：/index/index.php</span><br><span class="line">location = /index</span><br></pre></td></tr></table></figure></li></ol></blockquote><ol start="2"><li><p>^~ 表示匹配普通字符串 前缀匹配</p></li><li><p>~* 表示不区分大小写的正则匹配</p></li><li><p>~ 表示区分大小写的正则匹配</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim常见命令</title>
      <link href="/2017/11/08/vim-cmd-md/"/>
      <url>/2017/11/08/vim-cmd-md/</url>
      
        <content type="html"><![CDATA[<h3 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h3><ol><li><p>回到上次编辑的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctrl + o</span><br><span class="line">ctrl + i</span><br></pre></td></tr></table></figure></li><li><p>mark书签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m+[a-zA-Z] //定义书签</span><br><span class="line">&apos;+[a-zA-Z] //跳转到指定的书签</span><br><span class="line">:marks //显示所有的书签</span><br><span class="line">:delm[a-zA-Z] //删除指定的书签</span><br><span class="line">:delm! //删除所有书签</span><br></pre></td></tr></table></figure></li><li><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> //在指定行打开</span><br><span class="line">  vim +行号 file_name</span><br><span class="line"> //在包含指定字符串的行打开</span><br><span class="line">vm+/xxxx file_name</span><br></pre></td></tr></table></figure></li><li><p>在指定文件夹下 查找指定字符串 并且显示行号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -rn xxx *</span><br></pre></td></tr></table></figure></li></ol><p>3.翻页<br>ctrl+f//向下一页<br>ctrl+b//向上一页<br>ctrl+d//向下半页<br>ctrl+u//想上半页</p><ol start="4"><li>复制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yy //复制当前行</span><br></pre></td></tr></table></figure></li></ol><p>4.1 粘贴<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p 在光标下一行粘贴</span><br><span class="line">P 在光标上一行粘贴</span><br></pre></td></tr></table></figure></p><ol start="5"><li>进入插入模式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i 在光标之前插入</span><br><span class="line">a 在光标之后插入</span><br><span class="line">o 在当前行下一行插入新行</span><br><span class="line"></span><br><span class="line">6. 删除</span><br></pre></td></tr></table></figure></li></ol><p>dd 删除当前行</p><pre><code></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac下配置LNMP环境</title>
      <link href="/2017/11/08/mac-lnmp-md/"/>
      <url>/2017/11/08/mac-lnmp-md/</url>
      
        <content type="html"><![CDATA[<h3 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h3><h4 id="通过brew下载nginx"><a href="#通过brew下载nginx" class="headerlink" title="通过brew下载nginx"></a>通过brew下载nginx</h4><ol><li>通过brew安装</li><li>通过 brew 安装nginx<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure></li></ol><h4 id="通过源码安装"><a href="#通过源码安装" class="headerlink" title="通过源码安装"></a>通过源码安装</h4><ol><li><p>安装wget</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure></li><li><p>下载nginx源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.8.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>./configure</p></li><li>make</li><li>sudo make install</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> lnmp </tag>
            
            <tag> mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vituralbox 下 配置centos网络</title>
      <link href="/2017/11/08/linux-env-md/"/>
      <url>/2017/11/08/linux-env-md/</url>
      
        <content type="html"><![CDATA[<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ol><li>没有ifconfig 命令<blockquote><p>通过yum install net-tools安装</p></blockquote></li><li><p>没有网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 可能网卡没有启动 service network restart，</span><br><span class="line"> 设置开机自动启动</span><br><span class="line">vi /etc/sysconfig/network-scripts/ifconfig-xxx</span><br><span class="line">ONBOOT=NO //改成YES</span><br></pre></td></tr></table></figure></li><li><p>虚拟机配置的是动态ip  和本地ip不在一个网段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将虚拟机网络设置 改成 “桥接网卡”</span><br><span class="line">重新启动 试试</span><br></pre></td></tr></table></figure></li></ol><p>4、 本机 ssh 连接虚拟机 提示 22端口 refused<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一般是因为 虚拟主机 防火墙 限制导致的</span><br><span class="line">centos7防火墙使用的是 firewall</span><br><span class="line">//使用如下命令添加访问权限</span><br><span class="line">firewall-cmd --permanent --add-port=22/tcp</span><br><span class="line">firewall-cmd --reload //更新配置</span><br><span class="line">重新启动一个窗口 ssh连接（注意 如果还是在之前的窗口 可能一直不好使 ）</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux基础命令</title>
      <link href="/2017/11/08/linux-cmd1-md/"/>
      <url>/2017/11/08/linux-cmd1-md/</url>
      
        <content type="html"><![CDATA[<h2 id="find-查找文件"><a href="#find-查找文件" class="headerlink" title="find 查找文件"></a>find 查找文件</h2><ul><li>注意点<br>find 不支持正则表达式 只支持通配符<br>find是完全匹配</li></ul><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配任意内容</td></tr><tr><td>?</td><td>匹配任意一个字符</td></tr><tr><td>[]</td><td>匹配其中的任意一个字符</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//查找所有的文件</span><br><span class="line">find ./ -name &quot;*&quot;</span><br><span class="line"></span><br><span class="line">//查找以test开头的文件和文件夹</span><br><span class="line">find ./ -name test*</span><br><span class="line"></span><br><span class="line">//查找以test结尾的文件和文件夹</span><br><span class="line">find ./ -name *test</span><br><span class="line">//查找包含test的文件和文件夹</span><br><span class="line">find ./ -name *test*</span><br><span class="line"></span><br><span class="line">//查找当天创建的文件和文件夹</span><br><span class="line"> find ./ -ctime 0</span><br><span class="line">//查找1天之内创建的文件夹和文件</span><br><span class="line">find ./ -ctime -1</span><br><span class="line">//查找1天之前创建的文件件和文件</span><br><span class="line">find ./ ctime +1</span><br></pre></td></tr></table></figure><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>grep支持正则<br>grep是模糊匹配（最大范围匹配）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//查看包含了test的行</span><br><span class="line">grep test</span><br><span class="line">//查看以test结尾的行</span><br><span class="line">grep test$</span><br><span class="line">//查看以test开头的行</span><br><span class="line">grep ^test</span><br><span class="line">//查看是test的行</span><br><span class="line">grep ^test$</span><br><span class="line">//</span><br></pre></td></tr></table></figure></p><h3 id="针对用户的操作"><a href="#针对用户的操作" class="headerlink" title="针对用户的操作"></a>针对用户的操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">查看当前用户名</span><br><span class="line">who or whoami</span><br><span class="line">查看当前用户所在的用户组和组内其他成员</span><br><span class="line">groups user_name</span><br><span class="line">查看所有的用用户组</span><br><span class="line">cat /etc/group</span><br><span class="line">改变文件所属的用户组和用户名</span><br><span class="line">chown groupname:username  file_name</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centos下搭建LNMP环境</title>
      <link href="/2017/11/08/lnmp-md/"/>
      <url>/2017/11/08/lnmp-md/</url>
      
        <content type="html"><![CDATA[<h3 id="使用yum-安装nginx"><a href="#使用yum-安装nginx" class="headerlink" title="使用yum 安装nginx"></a>使用yum 安装nginx</h3><ol><li><p>添加nginx rpm依赖包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>使用yum 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure></li><li><p>启动nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx start // restart stop</span><br></pre></td></tr></table></figure></li></ol><p>2 如果发现访问 nginx 服务 被拒绝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//可能是防火墙 没有允许对应的端口</span><br><span class="line">firewall-cmd --list-port //查看允许的端口</span><br><span class="line">//添加对应的web服务端口</span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><h3 id="yum-安装mysql"><a href="#yum-安装mysql" class="headerlink" title="yum 安装mysql"></a>yum 安装mysql</h3><blockquote><p> 参考这个教程即可<br><a href="http://www.cnblogs.com/julyme/p/5969626.html" target="_blank" rel="noopener">http://www.cnblogs.com/julyme/p/5969626.html</a><br>TIPS:<br>教程中修改了mysql的密码 需要重新启动mysql服务 才能正常登陆。</p></blockquote><h3 id="yum-安装-php"><a href="#yum-安装-php" class="headerlink" title="yum 安装 php"></a>yum 安装 php</h3><ol><li>源码方式安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://hk1.php.net/get/php-7.1.11.tar.gz/from/this/mirror</span><br><span class="line">tar xzvf  php-7.1.11</span><br><span class="line">./configure --prefix=/usr/local/php --enable-fpm</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> lnmp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>思考</title>
      <link href="/2017/11/08/note-md/"/>
      <url>/2017/11/08/note-md/</url>
      
        <content type="html"><![CDATA[<p>当下，前端火的一塌糊涂，从当年的切图工种成长为当前最为抢手的职业。也使得这个职业从当初的草莽转为王牌军。</p><p>前端领域最大的一个特点应该就是变化。 前一段时间可能还在流行angular，过几天大家又开始讨论react了；刚学会了grunt，gulp有兴起了，才开始学习gulp，其他人又开始玩webpack了，其他的开发同学都开玩笑，你们前端真是会玩！</p><p>这些变化或者是新的技术框架是为了解决什么问题呢？相信大家都不会没事闲的整个框架完。我的理解是为了解决日益复杂的业务需求，为了适应当前业务中前端所承担的角色。</p><p>想想前端的洪荒时代，仅仅是为了处理表单更方便减轻服务器压力，而写几行js代码，我们也不需要什么模块管理工具，更用不到什么mvc，mvvm架构。 随着AJAX概念的出现，异步加载技术大大提升了web的用户体验，也为前端提供了更多的能力。Just remember: with great power comes great responsibility.</p><p>这样，随着前端承担越来越大业务，必然导致逻辑复杂性和代码复杂度以及代码的量增加，以前只需要几十行代码能搞定的事情，现在可能需要成千上万行实现。于是，n多浏览器的兼容性问题，全局变量，模块依赖，多人开发等问题，愈发凸显。prototype ,jquery 等库风行天下，cmd, amd 模块加载技术你挣我赶。再之后，大量业务逻辑和DOM操作混合杂糅，使得大型前端项目愈发艰难，难以为继。于是，开始借鉴后端的MVC思想来解决这种问题，backbone.js发力。结合前端特点，独辟蹊径，MVVM模式的框架入雨后春笋，angular,ember等等，风靡一时，react,vue更是独领风骚。<br>加上 h5 history新的api 可以操作当前的path和监听path的改变使得前端路由不需要再担心SEO问题（hash的前端路由方式最大的问题就是对于SEO的支持问题），单页应用越发健壮。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>amd-cmd</title>
      <link href="/2017/11/07/amd-cmd/"/>
      <url>/2017/11/07/amd-cmd/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 模块加载 </tag>
            
            <tag> cmd </tag>
            
            <tag> amd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现自己的一个简单vuejs</title>
      <link href="/2017/11/06/mini-vue/"/>
      <url>/2017/11/06/mini-vue/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们将参考大神的一个demo 一步一步解读如何实现一个自己的小型vuejs</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> mv* </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
